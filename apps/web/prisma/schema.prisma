generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id              String            @id @default(uuid())
  email           String            @unique
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  ownedWorkspaces Workspace[]
  workspaces      WorkspaceMember[]
}

model Workspace {
  id                String             @id @default(uuid())
  name              String
  ownerId           String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  owner             User               @relation(fields: [ownerId], references: [id])
  members           WorkspaceMember[]
  
  // New Messenger Architecture
  messengerPages    MessengerPage[]

  // Workflow integration (Fix for missing relations)
  instagramAccounts InstagramAccount[]
  workflowFolders   WorkflowFolder[]
  workflows        Workflow[]
  responseTemplates ResponseTemplate[]
  contacts          Contact[]
  automationRules   AutomationRule[]
}

model WorkspaceMember {
  id          String    @id @default(uuid())
  workspaceId String
  userId      String
  role        String
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id])
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  @@unique([workspaceId, userId])
}

// ---------------------------------------------------------
// MESSENGER SPECIFIC MODELS
// ---------------------------------------------------------

model MessengerPage {
  id                   String   @id @default(uuid())
  workspaceId          String
  pageId               String   @unique
  pageName             String
  pageAccessToken      String
  isActive             Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  workspace            Workspace @relation(fields: [workspaceId], references: [id])
  logs                 MessageLog[]
  contacts             Contact[]
  ruleExecutions       RuleExecution[]
  getStartedPayload    String?
  iceBreakers          Json?
}

model Contact {
  id              String   @id @default(uuid())
  workspaceId     String
  psid            String   // Messenger User ID (Page Scoped ID)
  firstName       String?
  lastName        String?
  profilePicUrl   String?
  firstSeenAt     DateTime @default(now())
  lastSeenAt      DateTime @default(now())
  lastMessageText String?
  tags            Json?    // ["tag1", "tag2"]
  
  workspace       Workspace @relation(fields: [workspaceId], references: [id])
  pageId          String?
  page            MessengerPage? @relation(fields: [pageId], references: [pageId]) 
  logs            MessageLog[]
  ruleExecutions  RuleExecution[]

  @@unique([pageId, psid])
  @@index([pageId])
  @@index([workspaceId])
}

model AutomationRule {
  id              String   @id @default(uuid())
  workspaceId     String
  name            String
  isActive        Boolean  @default(true)
  priority        Int      @default(0)
  matchType       String   // CONTAINS, EXACT, STARTS_WITH, REGEX
  keywords        String[]
  caseSensitive   Boolean  @default(false)
  normalizeAccents Boolean @default(true)
  matchOperator   String   // ANY, ALL
  cooldownSeconds Int      @default(0)
  schedule        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  workspace       Workspace @relation(fields: [workspaceId], references: [id])
  actions         AutomationAction[]
  executions      RuleExecution[]
  pageIds         String[] @default([])
  
  @@index([workspaceId, isActive])
}

model AutomationAction {
  id        String   @id @default(uuid())
  ruleId    String
  type      String   // TEXT, BUTTON_TEMPLATE, QUICK_REPLIES, AUDIO, FILE, IMAGE
  payload   Json
  order     Int      @default(0)
  delayMs   Int      @default(0)
  
  rule      AutomationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  
  @@index([ruleId, order])
}

model MessageLog {
  id            String   @id @default(uuid())
  contactId     String?
  pageId        String
  direction     String   // IN, OUT
  incomingText  String?
  matchedRuleId String?
  actionType    String?
  status        String   // RECEIVED, MATCHED, SENT, FAILED, SKIPPED, DUPLICATE
  error         String?
  rawEvent      Json?
  rawResponse   Json?
  createdAt     DateTime @default(now())

  contact       Contact? @relation(fields: [contactId], references: [id])
  page          MessengerPage @relation(fields: [pageId], references: [pageId]) 
  
  @@index([pageId, createdAt])
  @@index([contactId])
}

model RuleExecution {
  id             String   @id @default(uuid())
  ruleId         String
  contactId      String
  pageId         String?   // For faster filtering by page
  lastExecutedAt DateTime @default(now())
  timesExecuted  Int      @default(1)

  rule           AutomationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  contact        Contact        @relation(fields: [contactId], references: [id], onDelete: Cascade)
  page           MessengerPage? @relation(fields: [pageId], references: [pageId])
  
  @@index([pageId, lastExecutedAt])
  @@index([ruleId])
}

// ---------------------------------------------------------
// WORKFLOW SYSTEM MODELS (From packages/db)
// ---------------------------------------------------------

model InstagramAccount {
  id                   String   @id @default(uuid())
  workspaceId          String
  workspace            Workspace @relation(fields: [workspaceId], references: [id])
  igUserId             String
  username             String
  profilePicUrl        String?
  status               String   // CONNECTED, DISCONNECTED, TOKEN_EXPIRED
  accessTokenEncrypted String
  tokenExpiresAt       DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  followers         InstagramFollower[]
  
  @@unique([workspaceId, igUserId])
}

model InstagramFollower {
  id              String   @id @default(uuid())
  igUserId        String   
  username        String?
  tags            String[] @default([])
  accountId       String
  account         InstagramAccount @relation(fields: [accountId], references: [id])
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([igUserId, accountId])
}

model WorkflowFolder {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  name        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  workflows   Workflow[]
}

model Workflow {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  folderId    String?
  folder      WorkflowFolder? @relation(fields: [folderId], references: [id])
  title       String
  description String?
  channels    Json     // ["dm","story","feed"]
  flowDefinition Json? // Stores the visual graph (nodes/edges) state
  isActive    Boolean  @default(false)
  status      String   // DRAFT, PUBLISHED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  publishedAt DateTime?
  runCount    Int      @default(0)
  lastRunAt   DateTime?

  triggers        WorkflowTrigger[]
  actions         WorkflowAction[]
  automationRuns  AutomationRun[]
}

model WorkflowTrigger {
  id          String   @id @default(uuid())
  workflowId  String
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  type        String   // DM_RECEIVED, STORY_REPLY, FEED_COMMENT
  configJson  Json
}

model WorkflowAction {
  id          String   @id @default(uuid())
  workflowId  String
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  type        String   // SEND_DM, REPLY_COMMENT
  configJson  Json
}

model ResponseTemplate {
  id          String   @id @default(uuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  name        String
  body        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model WebhookEvent {
  id              String   @id @default(uuid())
  workspaceId     String?
  platform        String   // INSTAGRAM
  eventType       String
  platformEventId String   @unique // idempotency key
  payloadJson     Json
  receivedAt      DateTime @default(now())
  signatureValid  Boolean
  processedAt     DateTime?
  processingStatus String   // PENDING, PROCESSING, DONE, ERROR
  lastError       String?
  automationRuns  AutomationRun[]
}

model AutomationRun {
  id              String   @id @default(uuid())
  workflowId      String
  workflow        Workflow @relation(fields: [workflowId], references: [id])
  webhookEventId  String
  webhookEvent    WebhookEvent @relation(fields: [webhookEventId], references: [id])
  status          String   // SUCCESS, ERROR, SKIPPED
  startedAt       DateTime @default(now())
  finishedAt      DateTime?
  correlationId   String?
  errorMessage    String?
  logs            AutomationRunLog[]
}

model AutomationRunLog {
  id        String   @id @default(uuid())
  runId     String
  run       AutomationRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  ts        DateTime @default(now())
  level     String   // INFO, WARN, ERROR
  message   String
  metaJson  Json?
}
