"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer@11.1.3";
exports.ids = ["vendor-chunks/immer@11.1.3"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/immer@11.1.3/node_modules/immer/dist/immer.mjs":
/*!*******************************************************************************!*\
  !*** ../../node_modules/.pnpm/immer@11.1.3/node_modules/immer/dist/immer.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableArrayMethods: () => (/* binding */ enableArrayMethods),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictIteration: () => (/* binding */ setUseStrictIteration),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n// src/utils/errors.ts\nvar errors =  true ? [\n    // All error codes, starting by 0:\n    function(plugin) {\n        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n    },\n    function(thing) {\n        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n    },\n    \"This object has been frozen and should not be mutated\",\n    function(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    \"Immer forbids circular references\",\n    \"The first or second argument to `produce` must be a function\",\n    \"The third argument to `produce` must be a function or undefined\",\n    \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    function(thing) {\n        return `'current' expects a draft, got: ${thing}`;\n    },\n    \"Object.defineProperty() cannot be used on an Immer draft\",\n    \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    \"Immer only supports deleting array indices\",\n    \"Immer only supports setting array indices and the 'length' property\",\n    function(thing) {\n        return `'original' expects a draft, got: ${thing}`;\n    }\n] : 0;\nfunction die(error, ...args) {\n    if (true) {\n        const e = errors[error];\n        const msg = isFunction(e) ? e.apply(null, args) : e;\n        throw new Error(`[Immer] ${msg}`);\n    }\n    throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);\n}\n// src/utils/common.ts\nvar O = Object;\nvar getPrototypeOf = O.getPrototypeOf;\nvar CONSTRUCTOR = \"constructor\";\nvar PROTOTYPE = \"prototype\";\nvar CONFIGURABLE = \"configurable\";\nvar ENUMERABLE = \"enumerable\";\nvar WRITABLE = \"writable\";\nvar VALUE = \"value\";\nvar isDraft = (value)=>!!value && !!value[DRAFT_STATE];\nfunction isDraftable(value) {\n    if (!value) return false;\n    return isPlainObject(value) || isArray(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString();\nvar cachedCtorStrings = /* @__PURE__ */ new WeakMap();\nfunction isPlainObject(value) {\n    if (!value || !isObjectish(value)) return false;\n    const proto = getPrototypeOf(value);\n    if (proto === null || proto === O[PROTOTYPE]) return true;\n    const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];\n    if (Ctor === Object) return true;\n    if (!isFunction(Ctor)) return false;\n    let ctorString = cachedCtorStrings.get(Ctor);\n    if (ctorString === void 0) {\n        ctorString = Function.toString.call(Ctor);\n        cachedCtorStrings.set(Ctor, ctorString);\n    }\n    return ctorString === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(15, value);\n    return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter, strict = true) {\n    if (getArchtype(obj) === 0 /* Object */ ) {\n        const keys = strict ? Reflect.ownKeys(obj) : O.keys(obj);\n        keys.forEach((key)=>{\n            iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach((entry, index)=>iter(index, entry, obj));\n    }\n}\nfunction getArchtype(thing) {\n    const state = thing[DRAFT_STATE];\n    return state ? state.type_ : isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;\n}\nvar has = (thing, prop, type = getArchtype(thing))=>type === 2 /* Map */  ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);\nvar get = (thing, prop, type = getArchtype(thing))=>// @ts-ignore\n    type === 2 /* Map */  ? thing.get(prop) : thing[prop];\nvar set = (thing, propOrOldValue, value, type = getArchtype(thing))=>{\n    if (type === 2 /* Map */ ) thing.set(propOrOldValue, value);\n    else if (type === 3 /* Set */ ) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n};\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nvar isArray = Array.isArray;\nvar isMap = (target)=>target instanceof Map;\nvar isSet = (target)=>target instanceof Set;\nvar isObjectish = (target)=>typeof target === \"object\";\nvar isFunction = (target)=>typeof target === \"function\";\nvar isBoolean = (target)=>typeof target === \"boolean\";\nfunction isArrayIndex(value) {\n    const n = +value;\n    return Number.isInteger(n) && String(n) === value;\n}\nvar getProxyDraft = (value)=>{\n    if (!isObjectish(value)) return null;\n    return value?.[DRAFT_STATE];\n};\nvar latest = (state)=>state.copy_ || state.base_;\nvar getValue = (value)=>{\n    const proxyDraft = getProxyDraft(value);\n    return proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value;\n};\nvar getFinalValue = (state)=>state.modified_ ? state.copy_ : state.base_;\nfunction shallowCopy(base, strict) {\n    if (isMap(base)) {\n        return new Map(base);\n    }\n    if (isSet(base)) {\n        return new Set(base);\n    }\n    if (isArray(base)) return Array[PROTOTYPE].slice.call(base);\n    const isPlain = isPlainObject(base);\n    if (strict === true || strict === \"class_only\" && !isPlain) {\n        const descriptors = O.getOwnPropertyDescriptors(base);\n        delete descriptors[DRAFT_STATE];\n        let keys = Reflect.ownKeys(descriptors);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            const desc = descriptors[key];\n            if (desc[WRITABLE] === false) {\n                desc[WRITABLE] = true;\n                desc[CONFIGURABLE] = true;\n            }\n            if (desc.get || desc.set) descriptors[key] = {\n                [CONFIGURABLE]: true,\n                [WRITABLE]: true,\n                // could live with !!desc.set as well here...\n                [ENUMERABLE]: desc[ENUMERABLE],\n                [VALUE]: base[key]\n            };\n        }\n        return O.create(getPrototypeOf(base), descriptors);\n    } else {\n        const proto = getPrototypeOf(base);\n        if (proto !== null && isPlain) {\n            return {\n                ...base\n            };\n        }\n        const obj = O.create(proto);\n        return O.assign(obj, base);\n    }\n}\nfunction freeze(obj, deep = false) {\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        O.defineProperties(obj, {\n            set: dontMutateMethodOverride,\n            add: dontMutateMethodOverride,\n            clear: dontMutateMethodOverride,\n            delete: dontMutateMethodOverride\n        });\n    }\n    O.freeze(obj);\n    if (deep) each(obj, (_key, value)=>{\n        freeze(value, true);\n    }, false);\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nvar dontMutateMethodOverride = {\n    [VALUE]: dontMutateFrozenCollections\n};\nfunction isFrozen(obj) {\n    if (obj === null || !isObjectish(obj)) return true;\n    return O.isFrozen(obj);\n}\n// src/utils/plugins.ts\nvar PluginMapSet = \"MapSet\";\nvar PluginPatches = \"Patches\";\nvar PluginArrayMethods = \"ArrayMethods\";\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n    const plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(0, pluginKey);\n    }\n    return plugin;\n}\nvar isPluginLoaded = (pluginKey)=>!!plugins[pluginKey];\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\n// src/core/scope.ts\nvar currentScope;\nvar getCurrentScope = ()=>currentScope;\nvar createScope = (parent_, immer_)=>({\n        drafts_: [],\n        parent_,\n        immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0,\n        handledSet_: /* @__PURE__ */ new Set(),\n        processedForPatches_: /* @__PURE__ */ new Set(),\n        mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0,\n        arrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods) ? getPlugin(PluginArrayMethods) : void 0\n    });\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        scope.patchPlugin_ = getPlugin(PluginPatches);\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft);\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nvar enterScope = (immer2)=>currentScope = createScope(currentScope, immer2);\nfunction revokeDraft(draft) {\n    const state = draft[DRAFT_STATE];\n    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();\n    else state.revoked_ = true;\n}\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    const baseDraft = scope.drafts_[0];\n    const isReplaced = result !== void 0 && result !== baseDraft;\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            result = finalize(scope, result);\n        }\n        const { patchPlugin_ } = scope;\n        if (patchPlugin_) {\n            patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope);\n        }\n    } else {\n        result = finalize(scope, baseDraft);\n    }\n    maybeFreeze(scope, result, true);\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value) {\n    if (isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    if (!state) {\n        const finalValue = handleValue(value, rootScope.handledSet_, rootScope);\n        return finalValue;\n    }\n    if (!isSameScope(state, rootScope)) {\n        return value;\n    }\n    if (!state.modified_) {\n        return state.base_;\n    }\n    if (!state.finalized_) {\n        const { callbacks_ } = state;\n        if (callbacks_) {\n            while(callbacks_.length > 0){\n                const callback = callbacks_.pop();\n                callback(rootScope);\n            }\n        }\n        generatePatchesAndFinalize(state, rootScope);\n    }\n    return state.copy_;\n}\nfunction maybeFreeze(scope, value, deep = false) {\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\nfunction markStateFinalized(state) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n}\nvar isSameScope = (state, rootScope)=>state.scope_ === rootScope;\nvar EMPTY_LOCATIONS_RESULT = [];\nfunction updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {\n    const parentCopy = latest(parent);\n    const parentType = parent.type_;\n    if (originalKey !== void 0) {\n        const currentValue = get(parentCopy, originalKey, parentType);\n        if (currentValue === draftValue) {\n            set(parentCopy, originalKey, finalizedValue, parentType);\n            return;\n        }\n    }\n    if (!parent.draftLocations_) {\n        const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();\n        each(parentCopy, (key, value)=>{\n            if (isDraft(value)) {\n                const keys = draftLocations.get(value) || [];\n                keys.push(key);\n                draftLocations.set(value, keys);\n            }\n        });\n    }\n    const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;\n    for (const location of locations){\n        set(parentCopy, location, finalizedValue, parentType);\n    }\n}\nfunction registerChildFinalizationCallback(parent, child, key) {\n    parent.callbacks_.push(function childCleanup(rootScope) {\n        const state = child;\n        if (!state || !isSameScope(state, rootScope)) {\n            return;\n        }\n        rootScope.mapSetPlugin_?.fixSetContents(state);\n        const finalizedValue = getFinalValue(state);\n        updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key);\n        generatePatchesAndFinalize(state, rootScope);\n    });\n}\nfunction generatePatchesAndFinalize(state, rootScope) {\n    const shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3 /* Set */  || state.type_ === 1 /* Array */  && state.allIndicesReassigned_ || (state.assigned_?.size ?? 0) > 0);\n    if (shouldFinalize) {\n        const { patchPlugin_ } = rootScope;\n        if (patchPlugin_) {\n            const basePath = patchPlugin_.getPath(state);\n            if (basePath) {\n                patchPlugin_.generatePatches_(state, basePath, rootScope);\n            }\n        }\n        markStateFinalized(state);\n    }\n}\nfunction handleCrossReference(target, key, value) {\n    const { scope_ } = target;\n    if (isDraft(value)) {\n        const state = value[DRAFT_STATE];\n        if (isSameScope(state, scope_)) {\n            state.callbacks_.push(function crossReferenceCleanup() {\n                prepareCopy(target);\n                const finalizedValue = getFinalValue(state);\n                updateDraftInParent(target, value, finalizedValue, key);\n            });\n        }\n    } else if (isDraftable(value)) {\n        target.callbacks_.push(function nestedDraftCleanup() {\n            const targetCopy = latest(target);\n            if (target.type_ === 3 /* Set */ ) {\n                if (targetCopy.has(value)) {\n                    handleValue(value, scope_.handledSet_, scope_);\n                }\n            } else {\n                if (get(targetCopy, key, target.type_) === value) {\n                    if (scope_.drafts_.length > 1 && (target.assigned_.get(key) ?? false) === true && target.copy_) {\n                        handleValue(get(target.copy_, key, target.type_), scope_.handledSet_, scope_);\n                    }\n                }\n            }\n        });\n    }\n}\nfunction handleValue(target, handledSet, rootScope) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n        return target;\n    }\n    if (isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target)) {\n        return target;\n    }\n    handledSet.add(target);\n    each(target, (key, value)=>{\n        if (isDraft(value)) {\n            const state = value[DRAFT_STATE];\n            if (isSameScope(state, rootScope)) {\n                const updatedValue = getFinalValue(state);\n                set(target, key, updatedValue, target.type_);\n                markStateFinalized(state);\n            }\n        } else if (isDraftable(value)) {\n            handleValue(value, handledSet, rootScope);\n        }\n    });\n    return target;\n}\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n    const baseIsArray = isArray(base);\n    const state = {\n        type_: baseIsArray ? 1 /* Array */  : 0 /* Object */ ,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        // actually instantiated in `prepareCopy()`\n        assigned_: void 0,\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // set below\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false,\n        // `callbacks` actually gets assigned in `createProxy`\n        callbacks_: void 0\n    };\n    let target = state;\n    let traps = objectTraps;\n    if (baseIsArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    const { revoke, proxy } = Proxy.revocable(target, traps);\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return [\n        proxy,\n        state\n    ];\n}\nvar objectTraps = {\n    get (state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        let arrayPlugin = state.scope_.arrayMethodsPlugin_;\n        const isArrayWithStringProp = state.type_ === 1 /* Array */  && typeof prop === \"string\";\n        if (isArrayWithStringProp) {\n            if (arrayPlugin?.isArrayOperationMethod(prop)) {\n                return arrayPlugin.createMethodInterceptor(state, prop);\n            }\n        }\n        const source = latest(state);\n        if (!has(source, prop, state.type_)) {\n            return readPropFromProto(state, source, prop);\n        }\n        const value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        }\n        if (isArrayWithStringProp && state.operationMethod && arrayPlugin?.isMutatingArrayMethod(state.operationMethod) && isArrayIndex(prop)) {\n            return value;\n        }\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            const childKey = state.type_ === 1 /* Array */  ? +prop : prop;\n            const childDraft = createProxy(state.scope_, value, state, childKey);\n            return state.copy_[childKey] = childDraft;\n        }\n        return value;\n    },\n    has (state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys (state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set (state, prop, value) {\n        const desc = getDescriptorFromProto(latest(state), prop);\n        if (desc?.set) {\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            const current2 = peek(latest(state), prop);\n            const currentState = current2?.[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_.set(prop, false);\n                return true;\n            }\n            if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n        (value !== void 0 || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n        state.copy_[prop] = value;\n        state.assigned_.set(prop, true);\n        handleCrossReference(state, prop, value);\n        return true;\n    },\n    deleteProperty (state, prop) {\n        prepareCopy(state);\n        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n            state.assigned_.set(prop, false);\n            markChanged(state);\n        } else {\n            state.assigned_.delete(prop);\n        }\n        if (state.copy_) {\n            delete state.copy_[prop];\n        }\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor (state, prop) {\n        const owner = latest(state);\n        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            [WRITABLE]: true,\n            [CONFIGURABLE]: state.type_ !== 1 /* Array */  || prop !== \"length\",\n            [ENUMERABLE]: desc[ENUMERABLE],\n            [VALUE]: owner[prop]\n        };\n    },\n    defineProperty () {\n        die(11);\n    },\n    getPrototypeOf (state) {\n        return getPrototypeOf(state.base_);\n    },\n    setPrototypeOf () {\n        die(12);\n    }\n};\nvar arrayTraps = {};\nfor(let key in objectTraps){\n    let fn = objectTraps[key];\n    arrayTraps[key] = function() {\n        const args = arguments;\n        args[0] = args[0][0];\n        return fn.apply(this, args);\n    };\n}\narrayTraps.deleteProperty = function(state, prop) {\n    if ( true && isNaN(parseInt(prop))) die(13);\n    return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n    if ( true && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n    const state = draft[DRAFT_STATE];\n    const source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    const desc = getDescriptorFromProto(source, prop);\n    return desc ? VALUE in desc ? desc[VALUE] : // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n    if (!(prop in source)) return void 0;\n    let proto = getPrototypeOf(source);\n    while(proto){\n        const desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = getPrototypeOf(proto);\n    }\n    return void 0;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.assigned_ = /* @__PURE__ */ new Map();\n        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n    }\n}\n// src/core/immerClass.ts\nvar Immer2 = class {\n    constructor(config){\n        this.autoFreeze_ = true;\n        this.useStrictShallowCopy_ = false;\n        this.useStrictIteration_ = false;\n        /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */ this.produce = (base, recipe, patchListener)=>{\n            if (isFunction(base) && !isFunction(recipe)) {\n                const defaultBase = recipe;\n                recipe = base;\n                const self = this;\n                return function curriedProduce(base2 = defaultBase, ...args) {\n                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));\n                };\n            }\n            if (!isFunction(recipe)) die(6);\n            if (patchListener !== void 0 && !isFunction(patchListener)) die(7);\n            let result;\n            if (isDraftable(base)) {\n                const scope = enterScope(this);\n                const proxy = createProxy(scope, base, void 0);\n                let hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || !isObjectish(base)) {\n                result = recipe(base);\n                if (result === void 0) result = base;\n                if (result === NOTHING) result = void 0;\n                if (this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    const p = [];\n                    const ip = [];\n                    getPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n                        patches_: p,\n                        inversePatches_: ip\n                    });\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(1, base);\n        };\n        this.produceWithPatches = (base, recipe)=>{\n            if (isFunction(base)) {\n                return (state, ...args)=>this.produceWithPatches(state, (draft)=>base(draft, ...args));\n            }\n            let patches, inversePatches;\n            const result = this.produce(base, recipe, (p, ip)=>{\n                patches = p;\n                inversePatches = ip;\n            });\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config.autoFreeze);\n        if (isBoolean(config?.useStrictShallowCopy)) this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n        if (isBoolean(config?.useStrictIteration)) this.setUseStrictIteration(config.useStrictIteration);\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        const scope = enterScope(this);\n        const proxy = createProxy(scope, base, void 0);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE];\n        if (!state || !state.isManual_) die(9);\n        const { scope_: scope } = state;\n        usePatchesInScope(scope, patchListener);\n        return processResult(void 0, scope);\n    }\n    /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */ setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    }\n    /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */ setUseStrictShallowCopy(value) {\n        this.useStrictShallowCopy_ = value;\n    }\n    /**\n   * Pass false to use faster iteration that skips non-enumerable properties\n   * but still handles symbols for compatibility.\n   *\n   * By default, strict iteration is enabled (includes all own properties).\n   */ setUseStrictIteration(value) {\n        this.useStrictIteration_ = value;\n    }\n    shouldUseStrictIteration() {\n        return this.useStrictIteration_;\n    }\n    applyPatches(base, patches) {\n        let i;\n        for(i = patches.length - 1; i >= 0; i--){\n            const patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        }\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;\n        if (isDraft(base)) {\n            return applyPatchesImpl(base, patches);\n        }\n        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));\n    }\n};\nfunction createProxy(rootScope, value, parent, key) {\n    const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);\n    const scope = parent?.scope_ ?? getCurrentScope();\n    scope.drafts_.push(draft);\n    state.callbacks_ = parent?.callbacks_ ?? [];\n    state.key_ = key;\n    if (parent && key !== void 0) {\n        registerChildFinalizationCallback(parent, state, key);\n    } else {\n        state.callbacks_.push(function rootDraftCleanup(rootScope2) {\n            rootScope2.mapSetPlugin_?.fixSetContents(state);\n            const { patchPlugin_ } = rootScope2;\n            if (state.modified_ && patchPlugin_) {\n                patchPlugin_.generatePatches_(state, [], rootScope2);\n            }\n        });\n    }\n    return draft;\n}\n// src/core/current.ts\nfunction current(value) {\n    if (!isDraft(value)) die(10, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value) || isFrozen(value)) return value;\n    const state = value[DRAFT_STATE];\n    let copy;\n    let strict = true;\n    if (state) {\n        if (!state.modified_) return state.base_;\n        state.finalized_ = true;\n        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n        strict = state.scope_.immer_.shouldUseStrictIteration();\n    } else {\n        copy = shallowCopy(value, true);\n    }\n    each(copy, (key, childValue)=>{\n        set(copy, key, currentImpl(childValue));\n    }, strict);\n    if (state) {\n        state.finalized_ = false;\n    }\n    return copy;\n}\n// src/plugins/patches.ts\nfunction enablePatches() {\n    const errorOffset = 16;\n    if (true) {\n        errors.push('Sets cannot have \"replace\" patches.', function(op) {\n            return \"Unsupported patch operation: \" + op;\n        }, function(path) {\n            return \"Cannot apply patch, path doesn't resolve: \" + path;\n        }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n    }\n    function getPath(state, path = []) {\n        if (state.key_ !== void 0) {\n            const parentCopy = state.parent_.copy_ ?? state.parent_.base_;\n            const proxyDraft = getProxyDraft(get(parentCopy, state.key_));\n            const valueAtKey = get(parentCopy, state.key_);\n            if (valueAtKey === void 0) {\n                return null;\n            }\n            if (valueAtKey !== state.draft_ && valueAtKey !== state.base_ && valueAtKey !== state.copy_) {\n                return null;\n            }\n            if (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n                return null;\n            }\n            const isSet2 = state.parent_.type_ === 3 /* Set */ ;\n            let key;\n            if (isSet2) {\n                const setParent = state.parent_;\n                key = Array.from(setParent.drafts_.keys()).indexOf(state.key_);\n            } else {\n                key = state.key_;\n            }\n            if (!(isSet2 && parentCopy.size > key || has(parentCopy, key))) {\n                return null;\n            }\n            path.push(key);\n        }\n        if (state.parent_) {\n            return getPath(state.parent_, path);\n        }\n        path.reverse();\n        try {\n            resolvePath(state.copy_, path);\n        } catch (e) {\n            return null;\n        }\n        return path;\n    }\n    function resolvePath(base, path) {\n        let current2 = base;\n        for(let i = 0; i < path.length - 1; i++){\n            const key = path[i];\n            current2 = get(current2, key);\n            if (!isObjectish(current2) || current2 === null) {\n                throw new Error(`Cannot resolve path at '${path.join(\"/\")}'`);\n            }\n        }\n        return current2;\n    }\n    const REPLACE = \"replace\";\n    const ADD = \"add\";\n    const REMOVE = \"remove\";\n    function generatePatches_(state, basePath, scope) {\n        if (state.scope_.processedForPatches_.has(state)) {\n            return;\n        }\n        state.scope_.processedForPatches_.add(state);\n        const { patches_, inversePatches_ } = scope;\n        switch(state.type_){\n            case 0 /* Object */ :\n            case 2 /* Map */ :\n                return generatePatchesFromAssigned(state, basePath, patches_, inversePatches_);\n            case 1 /* Array */ :\n                return generateArrayPatches(state, basePath, patches_, inversePatches_);\n            case 3 /* Set */ :\n                return generateSetPatches(state, basePath, patches_, inversePatches_);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        let { base_, assigned_ } = state;\n        let copy_ = state.copy_;\n        if (copy_.length < base_.length) {\n            ;\n            [base_, copy_] = [\n                copy_,\n                base_\n            ];\n            [patches, inversePatches] = [\n                inversePatches,\n                patches\n            ];\n        }\n        const allReassigned = state.allIndicesReassigned_ === true;\n        for(let i = 0; i < base_.length; i++){\n            const copiedItem = copy_[i];\n            const baseItem = base_[i];\n            const isAssigned = allReassigned || assigned_?.get(i.toString());\n            if (isAssigned && copiedItem !== baseItem) {\n                const childState = copiedItem?.[DRAFT_STATE];\n                if (childState && childState.modified_) {\n                    continue;\n                }\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copiedItem)\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path,\n                    value: clonePatchValueIfNeeded(baseItem)\n                });\n            }\n        }\n        for(let i = base_.length; i < copy_.length; i++){\n            const path = basePath.concat([\n                i\n            ]);\n            patches.push({\n                op: ADD,\n                path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[i])\n            });\n        }\n        for(let i = copy_.length - 1; base_.length <= i; --i){\n            const path = basePath.concat([\n                i\n            ]);\n            inversePatches.push({\n                op: REMOVE,\n                path\n            });\n        }\n    }\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        const { base_, copy_, type_ } = state;\n        each(state.assigned_, (key, assignedValue)=>{\n            const origValue = get(base_, key, type_);\n            const value = get(copy_, key, type_);\n            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            const path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op,\n                path\n            } : {\n                op,\n                path,\n                value: clonePatchValueIfNeeded(value)\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path\n            } : op === REMOVE ? {\n                op: ADD,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        let { base_, copy_ } = state;\n        let i = 0;\n        base_.forEach((value)=>{\n            if (!copy_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach((value)=>{\n            if (!base_.has(value)) {\n                const path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path,\n                    value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path,\n                    value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, scope) {\n        const { patches_, inversePatches_ } = scope;\n        patches_.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? void 0 : replacement\n        });\n        inversePatches_.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach((patch)=>{\n            const { path, op } = patch;\n            let base = draft;\n            for(let i = 0; i < path.length - 1; i++){\n                const parentType = getArchtype(base);\n                let p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                }\n                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === \"__proto__\" || p === CONSTRUCTOR)) die(errorOffset + 3);\n                if (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3);\n                base = get(base, p);\n                if (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"));\n            }\n            const type = getArchtype(base);\n            const value = deepClonePatchValue(patch.value);\n            const key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            die(errorOffset);\n                        default:\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2 /* Map */ :\n                            return base.set(key, value);\n                        case 3 /* Set */ :\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1 /* Array */ :\n                            return base.splice(key, 1);\n                        case 2 /* Map */ :\n                            return base.delete(key);\n                        case 3 /* Set */ :\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(errorOffset + 1, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(([k, v])=>[\n                k,\n                deepClonePatchValue(v)\n            ]));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        const cloned = Object.create(getPrototypeOf(obj));\n        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(PluginPatches, {\n        applyPatches_,\n        generatePatches_,\n        generateReplacementPatches_,\n        getPath\n    });\n}\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n    class DraftMap extends Map {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 2 /* Map */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                assigned_: void 0,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false,\n                callbacks_: []\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        }\n        set(key, value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n                handleCrossReference(state, key, value);\n            }\n            return this;\n        }\n        delete(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = /* @__PURE__ */ new Map();\n                each(state.base_, (key)=>{\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        }\n        forEach(cb, thisArg) {\n            const state = this[DRAFT_STATE];\n            latest(state).forEach((_value, key, _map)=>{\n                cb.call(thisArg, this.get(key), key, this);\n            });\n        }\n        get(key) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            const value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value;\n            }\n            const draft = createProxy(state.scope_, value, state, key);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        }\n        keys() {\n            return latest(this[DRAFT_STATE]).keys();\n        }\n        values() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.values(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value\n                    };\n                }\n            };\n        }\n        entries() {\n            const iterator = this.keys();\n            return {\n                [Symbol.iterator]: ()=>this.entries(),\n                next: ()=>{\n                    const r = iterator.next();\n                    if (r.done) return r;\n                    const value = this.get(r.value);\n                    return {\n                        done: false,\n                        value: [\n                            r.value,\n                            value\n                        ]\n                    };\n                }\n            };\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.entries();\n        }\n    }\n    function proxyMap_(target, parent) {\n        const map = new DraftMap(target, parent);\n        return [\n            map,\n            map[DRAFT_STATE]\n        ];\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = /* @__PURE__ */ new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    class DraftSet extends Set {\n        constructor(target, parent){\n            super();\n            this[DRAFT_STATE] = {\n                type_: 3 /* Set */ ,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: void 0,\n                base_: target,\n                draft_: this,\n                drafts_: /* @__PURE__ */ new Map(),\n                revoked_: false,\n                isManual_: false,\n                assigned_: void 0,\n                callbacks_: []\n            };\n        }\n        get size() {\n            return latest(this[DRAFT_STATE]).size;\n        }\n        has(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        }\n        add(value) {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n                handleCrossReference(state, value, value);\n            }\n            return this;\n        }\n        delete(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        }\n        clear() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        }\n        values() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        }\n        entries() {\n            const state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        }\n        keys() {\n            return this.values();\n        }\n        [(DRAFT_STATE, Symbol.iterator)]() {\n            return this.values();\n        }\n        forEach(cb, thisArg) {\n            const iterator = this.values();\n            let result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        }\n    }\n    function proxySet_(target, parent) {\n        const set2 = new DraftSet(target, parent);\n        return [\n            set2,\n            set2[DRAFT_STATE]\n        ];\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            state.copy_ = /* @__PURE__ */ new Set();\n            state.base_.forEach((value)=>{\n                if (isDraftable(value)) {\n                    const draft = createProxy(state.scope_, value, state, value);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    function fixSetContents(target) {\n        if (target.type_ === 3 /* Set */  && target.copy_) {\n            const copy = new Set(target.copy_);\n            target.copy_.clear();\n            copy.forEach((value)=>{\n                target.copy_.add(getValue(value));\n            });\n        }\n    }\n    loadPlugin(PluginMapSet, {\n        proxyMap_,\n        proxySet_,\n        fixSetContents\n    });\n}\n// src/plugins/arrayMethods.ts\nfunction enableArrayMethods() {\n    const SHIFTING_METHODS = /* @__PURE__ */ new Set([\n        \"shift\",\n        \"unshift\"\n    ]);\n    const QUEUE_METHODS = /* @__PURE__ */ new Set([\n        \"push\",\n        \"pop\"\n    ]);\n    const RESULT_RETURNING_METHODS = /* @__PURE__ */ new Set([\n        ...QUEUE_METHODS,\n        ...SHIFTING_METHODS\n    ]);\n    const REORDERING_METHODS = /* @__PURE__ */ new Set([\n        \"reverse\",\n        \"sort\"\n    ]);\n    const MUTATING_METHODS = /* @__PURE__ */ new Set([\n        ...RESULT_RETURNING_METHODS,\n        ...REORDERING_METHODS,\n        \"splice\"\n    ]);\n    const FIND_METHODS = /* @__PURE__ */ new Set([\n        \"find\",\n        \"findLast\"\n    ]);\n    const NON_MUTATING_METHODS = /* @__PURE__ */ new Set([\n        \"filter\",\n        \"slice\",\n        \"concat\",\n        \"flat\",\n        ...FIND_METHODS,\n        \"findIndex\",\n        \"findLastIndex\",\n        \"some\",\n        \"every\",\n        \"indexOf\",\n        \"lastIndexOf\",\n        \"includes\",\n        \"join\",\n        \"toString\",\n        \"toLocaleString\"\n    ]);\n    function isMutatingArrayMethod(method) {\n        return MUTATING_METHODS.has(method);\n    }\n    function isNonMutatingArrayMethod(method) {\n        return NON_MUTATING_METHODS.has(method);\n    }\n    function isArrayOperationMethod(method) {\n        return isMutatingArrayMethod(method) || isNonMutatingArrayMethod(method);\n    }\n    function enterOperation(state, method) {\n        state.operationMethod = method;\n    }\n    function exitOperation(state) {\n        state.operationMethod = void 0;\n    }\n    function executeArrayMethod(state, operation, markLength = true) {\n        prepareCopy(state);\n        const result = operation();\n        markChanged(state);\n        if (markLength) state.assigned_.set(\"length\", true);\n        return result;\n    }\n    function markAllIndicesReassigned(state) {\n        state.allIndicesReassigned_ = true;\n    }\n    function normalizeSliceIndex(index, length) {\n        if (index < 0) {\n            return Math.max(length + index, 0);\n        }\n        return Math.min(index, length);\n    }\n    function handleSimpleOperation(state, method, args) {\n        return executeArrayMethod(state, ()=>{\n            const result = state.copy_[method](...args);\n            if (SHIFTING_METHODS.has(method)) {\n                markAllIndicesReassigned(state);\n            }\n            return RESULT_RETURNING_METHODS.has(method) ? result : state.draft_;\n        });\n    }\n    function handleReorderingOperation(state, method, args) {\n        return executeArrayMethod(state, ()=>{\n            ;\n            state.copy_[method](...args);\n            markAllIndicesReassigned(state);\n            return state.draft_;\n        }, false);\n    }\n    function createMethodInterceptor(state, originalMethod) {\n        return function interceptedMethod(...args) {\n            const method = originalMethod;\n            enterOperation(state, method);\n            try {\n                if (isMutatingArrayMethod(method)) {\n                    if (RESULT_RETURNING_METHODS.has(method)) {\n                        return handleSimpleOperation(state, method, args);\n                    }\n                    if (REORDERING_METHODS.has(method)) {\n                        return handleReorderingOperation(state, method, args);\n                    }\n                    if (method === \"splice\") {\n                        const res = executeArrayMethod(state, ()=>state.copy_.splice(...args));\n                        markAllIndicesReassigned(state);\n                        return res;\n                    }\n                } else {\n                    return handleNonMutatingOperation(state, method, args);\n                }\n            } finally{\n                exitOperation(state);\n            }\n        };\n    }\n    function handleNonMutatingOperation(state, method, args) {\n        const source = latest(state);\n        if (method === \"filter\") {\n            const predicate = args[0];\n            const result = [];\n            for(let i = 0; i < source.length; i++){\n                if (predicate(source[i], i, source)) {\n                    result.push(state.draft_[i]);\n                }\n            }\n            return result;\n        }\n        if (FIND_METHODS.has(method)) {\n            const predicate = args[0];\n            const isForward = method === \"find\";\n            const step = isForward ? 1 : -1;\n            const start = isForward ? 0 : source.length - 1;\n            for(let i = start; i >= 0 && i < source.length; i += step){\n                if (predicate(source[i], i, source)) {\n                    return state.draft_[i];\n                }\n            }\n            return void 0;\n        }\n        if (method === \"slice\") {\n            const rawStart = args[0] ?? 0;\n            const rawEnd = args[1] ?? source.length;\n            const start = normalizeSliceIndex(rawStart, source.length);\n            const end = normalizeSliceIndex(rawEnd, source.length);\n            const result = [];\n            for(let i = start; i < end; i++){\n                result.push(state.draft_[i]);\n            }\n            return result;\n        }\n        return source[method](...args);\n    }\n    loadPlugin(PluginArrayMethods, {\n        createMethodInterceptor,\n        isArrayOperationMethod,\n        isMutatingArrayMethod\n    });\n}\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);\nvar setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);\nvar applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);\nvar createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);\nvar finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);\nvar castDraft = (value)=>value;\nvar castImmutable = (value)=>value;\n //# sourceMappingURL=immer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDExLjEuMy9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUJBQW1CO0FBQ25CLElBQUlBLFVBQVVDLE9BQU9DLEdBQUcsQ0FBQztBQUN6QixJQUFJQyxZQUFZRixPQUFPQyxHQUFHLENBQUM7QUFDM0IsSUFBSUUsY0FBY0gsT0FBT0MsR0FBRyxDQUFDO0FBRTdCLHNCQUFzQjtBQUN0QixJQUFJRyxTQUFTQyxLQUFxQyxHQUFHO0lBQ25ELGtDQUFrQztJQUNsQyxTQUFTQyxNQUFNO1FBQ2IsT0FBTyxDQUFDLGdCQUFnQixFQUFFQSxPQUFPLGdGQUFnRixFQUFFQSxPQUFPLHdDQUF3QyxDQUFDO0lBQ3JLO0lBQ0EsU0FBU0MsS0FBSztRQUNaLE9BQU8sQ0FBQyxtSkFBbUosRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDdks7SUFDQTtJQUNBLFNBQVNDLElBQUk7UUFDWCxPQUFPLHlIQUF5SEE7SUFDbEk7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTRCxLQUFLO1FBQ1osT0FBTyxDQUFDLGdDQUFnQyxFQUFFQSxNQUFNLENBQUM7SUFDbkQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVNBLEtBQUs7UUFDWixPQUFPLENBQUMsaUNBQWlDLEVBQUVBLE1BQU0sQ0FBQztJQUNwRDtDQUdELEdBQUcsQ0FBRTtBQUNOLFNBQVNFLElBQUlDLEtBQUssRUFBRSxHQUFHQyxJQUFJO0lBQ3pCLElBQUlOLElBQXFDLEVBQUU7UUFDekMsTUFBTU8sSUFBSVIsTUFBTSxDQUFDTSxNQUFNO1FBQ3ZCLE1BQU1HLE1BQU1DLFdBQVdGLEtBQUtBLEVBQUVHLEtBQUssQ0FBQyxNQUFNSixRQUFRQztRQUNsRCxNQUFNLElBQUlJLE1BQU0sQ0FBQyxRQUFRLEVBQUVILElBQUksQ0FBQztJQUNsQztJQUNBLE1B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R3dHLE1BQU14RyxXQUFXLENBQUN5RyxJQUFJLENBQUNEO0FBQ3pELElBQUl0RyxjQUFjLGFBQWEsR0FBR3NHLE1BQU10RyxXQUFXLENBQUN1RyxJQUFJLENBQUNEO0FBQ3pELElBQUlFLFlBQVksQ0FBQzVVLFFBQVVBO0FBQzNCLElBQUk2VSxnQkFBZ0IsQ0FBQzdVLFFBQVVBO0FBdUI3QixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkbmV4dC13ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDExLjEuMy9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanM/OTFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZW52LnRzXG52YXIgTk9USElORyA9IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpO1xudmFyIERSQUZUQUJMRSA9IFN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik7XG52YXIgRFJBRlRfU1RBVEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik7XG5cbi8vIHNyYy91dGlscy9lcnJvcnMudHNcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbXG4gIC8vIEFsbCBlcnJvciBjb2Rlcywgc3RhcnRpbmcgYnkgMDpcbiAgZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgcmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gO1xuICB9LFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYDtcbiAgfSxcbiAgXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH0sXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfVxuICAvLyBOb3RlOiBpZiBtb3JlIGVycm9ycyBhcmUgYWRkZWQsIHRoZSBlcnJvck9mZnNldCBpbiBQYXRjaGVzLnRzIHNob3VsZCBiZSBpbmNyZWFzZWRcbiAgLy8gU2VlIFBhdGNoZXMudHMgZm9yIGFkZGl0aW9uYWwgZXJyb3JzXG5dIDogW107XG5mdW5jdGlvbiBkaWUoZXJyb3IsIC4uLmFyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdO1xuICAgIGNvbnN0IG1zZyA9IGlzRnVuY3Rpb24oZSkgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbW1vbi50c1xudmFyIE8gPSBPYmplY3Q7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPLmdldFByb3RvdHlwZU9mO1xudmFyIENPTlNUUlVDVE9SID0gXCJjb25zdHJ1Y3RvclwiO1xudmFyIFBST1RPVFlQRSA9IFwicHJvdG90eXBlXCI7XG52YXIgQ09ORklHVVJBQkxFID0gXCJjb25maWd1cmFibGVcIjtcbnZhciBFTlVNRVJBQkxFID0gXCJlbnVtZXJhYmxlXCI7XG52YXIgV1JJVEFCTEUgPSBcIndyaXRhYmxlXCI7XG52YXIgVkFMVUUgPSBcInZhbHVlXCI7XG52YXIgaXNEcmFmdCA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbmZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkgfHwgISF2YWx1ZVtEUkFGVEFCTEVdIHx8ICEhdmFsdWVbQ09OU1RSVUNUT1JdPy5bRFJBRlRBQkxFXSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xufVxudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBPW1BST1RPVFlQRV1bQ09OU1RSVUNUT1JdLnRvU3RyaW5nKCk7XG52YXIgY2FjaGVkQ3RvclN0cmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCAhaXNPYmplY3Rpc2godmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCB8fCBwcm90byA9PT0gT1tQUk9UT1RZUEVdKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBDdG9yID0gTy5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBDT05TVFJVQ1RPUikgJiYgcHJvdG9bQ09OU1RSVUNUT1JdO1xuICBpZiAoQ3RvciA9PT0gT2JqZWN0KVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoIWlzRnVuY3Rpb24oQ3RvcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgY3RvclN0cmluZyA9IGNhY2hlZEN0b3JTdHJpbmdzLmdldChDdG9yKTtcbiAgaWYgKGN0b3JTdHJpbmcgPT09IHZvaWQgMCkge1xuICAgIGN0b3JTdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpO1xuICAgIGNhY2hlZEN0b3JTdHJpbmdzLnNldChDdG9yLCBjdG9yU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gY3RvclN0cmluZyA9PT0gb2JqZWN0Q3RvclN0cmluZztcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDE1LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgc3RyaWN0ID0gdHJ1ZSkge1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMCAvKiBPYmplY3QgKi8pIHtcbiAgICBjb25zdCBrZXlzID0gc3RyaWN0ID8gUmVmbGVjdC5vd25LZXlzKG9iaikgOiBPLmtleXMob2JqKTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaXRlcihrZXksIG9ialtrZXldLCBvYmopO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iai5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV07XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLnR5cGVfIDogaXNBcnJheSh0aGluZykgPyAxIC8qIEFycmF5ICovIDogaXNNYXAodGhpbmcpID8gMiAvKiBNYXAgKi8gOiBpc1NldCh0aGluZykgPyAzIC8qIFNldCAqLyA6IDAgLyogT2JqZWN0ICovO1xufVxudmFyIGhhcyA9ICh0aGluZywgcHJvcCwgdHlwZSA9IGdldEFyY2h0eXBlKHRoaW5nKSkgPT4gdHlwZSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5oYXMocHJvcCkgOiBPW1BST1RPVFlQRV0uaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG52YXIgZ2V0ID0gKHRoaW5nLCBwcm9wLCB0eXBlID0gZ2V0QXJjaHR5cGUodGhpbmcpKSA9PiAoXG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXVxuKTtcbnZhciBzZXQgPSAodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSwgdHlwZSA9IGdldEFyY2h0eXBlKHRoaW5nKSkgPT4ge1xuICBpZiAodHlwZSA9PT0gMiAvKiBNYXAgKi8pXG4gICAgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7XG4gIGVsc2UgaWYgKHR5cGUgPT09IDMgLyogU2V0ICovKSB7XG4gICAgdGhpbmcuYWRkKHZhbHVlKTtcbiAgfSBlbHNlXG4gICAgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWU7XG59O1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgaXNNYXAgPSAodGFyZ2V0KSA9PiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XG52YXIgaXNTZXQgPSAodGFyZ2V0KSA9PiB0YXJnZXQgaW5zdGFuY2VvZiBTZXQ7XG52YXIgaXNPYmplY3Rpc2ggPSAodGFyZ2V0KSA9PiB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiO1xudmFyIGlzRnVuY3Rpb24gPSAodGFyZ2V0KSA9PiB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCI7XG52YXIgaXNCb29sZWFuID0gKHRhcmdldCkgPT4gdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCI7XG5mdW5jdGlvbiBpc0FycmF5SW5kZXgodmFsdWUpIHtcbiAgY29uc3QgbiA9ICt2YWx1ZTtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobikgJiYgU3RyaW5nKG4pID09PSB2YWx1ZTtcbn1cbnZhciBnZXRQcm94eURyYWZ0ID0gKHZhbHVlKSA9PiB7XG4gIGlmICghaXNPYmplY3Rpc2godmFsdWUpKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gdmFsdWU/LltEUkFGVF9TVEFURV07XG59O1xudmFyIGxhdGVzdCA9IChzdGF0ZSkgPT4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XG52YXIgZ2V0VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgcHJveHlEcmFmdCA9IGdldFByb3h5RHJhZnQodmFsdWUpO1xuICByZXR1cm4gcHJveHlEcmFmdCA/IHByb3h5RHJhZnQuY29weV8gPz8gcHJveHlEcmFmdC5iYXNlXyA6IHZhbHVlO1xufTtcbnZhciBnZXRGaW5hbFZhbHVlID0gKHN0YXRlKSA9PiBzdGF0ZS5tb2RpZmllZF8gPyBzdGF0ZS5jb3B5XyA6IHN0YXRlLmJhc2VfO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZSwgc3RyaWN0KSB7XG4gIGlmIChpc01hcChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGJhc2UpO1xuICB9XG4gIGlmIChpc1NldChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgU2V0KGJhc2UpO1xuICB9XG4gIGlmIChpc0FycmF5KGJhc2UpKVxuICAgIHJldHVybiBBcnJheVtQUk9UT1RZUEVdLnNsaWNlLmNhbGwoYmFzZSk7XG4gIGNvbnN0IGlzUGxhaW4gPSBpc1BsYWluT2JqZWN0KGJhc2UpO1xuICBpZiAoc3RyaWN0ID09PSB0cnVlIHx8IHN0cmljdCA9PT0gXCJjbGFzc19vbmx5XCIgJiYgIWlzUGxhaW4pIHtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE8uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgICBkZWxldGUgZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICAgIGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcbiAgICAgIGlmIChkZXNjW1dSSVRBQkxFXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVzY1tXUklUQUJMRV0gPSB0cnVlO1xuICAgICAgICBkZXNjW0NPTkZJR1VSQUJMRV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuICAgICAgICBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgICAgIFtDT05GSUdVUkFCTEVdOiB0cnVlLFxuICAgICAgICAgIFtXUklUQUJMRV06IHRydWUsXG4gICAgICAgICAgLy8gY291bGQgbGl2ZSB3aXRoICEhZGVzYy5zZXQgYXMgd2VsbCBoZXJlLi4uXG4gICAgICAgICAgW0VOVU1FUkFCTEVdOiBkZXNjW0VOVU1FUkFCTEVdLFxuICAgICAgICAgIFtWQUxVRV06IGJhc2Vba2V5XVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gTy5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvdHlwZU9mKGJhc2UpO1xuICAgIGlmIChwcm90byAhPT0gbnVsbCAmJiBpc1BsYWluKSB7XG4gICAgICByZXR1cm4geyAuLi5iYXNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IE8uY3JlYXRlKHByb3RvKTtcbiAgICByZXR1cm4gTy5hc3NpZ24ob2JqLCBiYXNlKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSlcbiAgICByZXR1cm4gb2JqO1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDEpIHtcbiAgICBPLmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgICBzZXQ6IGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSxcbiAgICAgIGFkZDogZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlLFxuICAgICAgY2xlYXI6IGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSxcbiAgICAgIGRlbGV0ZTogZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlXG4gICAgfSk7XG4gIH1cbiAgTy5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApXG4gICAgZWFjaChcbiAgICAgIG9iaixcbiAgICAgIChfa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBmcmVlemUodmFsdWUsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcbiAgZGllKDIpO1xufVxudmFyIGRvbnRNdXRhdGVNZXRob2RPdmVycmlkZSA9IHtcbiAgW1ZBTFVFXTogZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zXG59O1xuZnVuY3Rpb24gaXNGcm96ZW4ob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgIWlzT2JqZWN0aXNoKG9iaikpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBPLmlzRnJvemVuKG9iaik7XG59XG5cbi8vIHNyYy91dGlscy9wbHVnaW5zLnRzXG52YXIgUGx1Z2luTWFwU2V0ID0gXCJNYXBTZXRcIjtcbnZhciBQbHVnaW5QYXRjaGVzID0gXCJQYXRjaGVzXCI7XG52YXIgUGx1Z2luQXJyYXlNZXRob2RzID0gXCJBcnJheU1ldGhvZHNcIjtcbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XTtcbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMCwgcGx1Z2luS2V5KTtcbiAgfVxuICByZXR1cm4gcGx1Z2luO1xufVxudmFyIGlzUGx1Z2luTG9hZGVkID0gKHBsdWdpbktleSkgPT4gISFwbHVnaW5zW3BsdWdpbktleV07XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xudmFyIGdldEN1cnJlbnRTY29wZSA9ICgpID0+IGN1cnJlbnRTY29wZTtcbnZhciBjcmVhdGVTY29wZSA9IChwYXJlbnRfLCBpbW1lcl8pID0+ICh7XG4gIGRyYWZ0c186IFtdLFxuICBwYXJlbnRfLFxuICBpbW1lcl8sXG4gIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gIHVuZmluYWxpemVkRHJhZnRzXzogMCxcbiAgaGFuZGxlZFNldF86IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIHByb2Nlc3NlZEZvclBhdGNoZXNfOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBtYXBTZXRQbHVnaW5fOiBpc1BsdWdpbkxvYWRlZChQbHVnaW5NYXBTZXQpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkgOiB2b2lkIDAsXG4gIGFycmF5TWV0aG9kc1BsdWdpbl86IGlzUGx1Z2luTG9hZGVkKFBsdWdpbkFycmF5TWV0aG9kcykgPyBnZXRQbHVnaW4oUGx1Z2luQXJyYXlNZXRob2RzKSA6IHZvaWQgMFxufSk7XG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIHNjb3BlLnBhdGNoUGx1Z2luXyA9IGdldFBsdWdpbihQbHVnaW5QYXRjaGVzKTtcbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gcmV2b2tlU2NvcGUoc2NvcGUpIHtcbiAgbGVhdmVTY29wZShzY29wZSk7XG4gIHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdCk7XG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbnZhciBlbnRlclNjb3BlID0gKGltbWVyMikgPT4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcjIpO1xuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXG4gICAgc3RhdGUucmV2b2tlXygpO1xuICBlbHNlXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICBjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXRjaFBsdWdpbl8gfSA9IHNjb3BlO1xuICAgIGlmIChwYXRjaFBsdWdpbl8pIHtcbiAgICAgIHBhdGNoUGx1Z2luXy5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgICAgIGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc2NvcGVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQpO1xuICB9XG4gIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQsIHRydWUpO1xuICByZXZva2VTY29wZShzY29wZSk7XG4gIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICB9XG4gIHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGUsIHZhbHVlKSB7XG4gIGlmIChpc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIGNvbnN0IGZpbmFsVmFsdWUgPSBoYW5kbGVWYWx1ZSh2YWx1ZSwgcm9vdFNjb3BlLmhhbmRsZWRTZXRfLCByb290U2NvcGUpO1xuICAgIHJldHVybiBmaW5hbFZhbHVlO1xuICB9XG4gIGlmICghaXNTYW1lU2NvcGUoc3RhdGUsIHJvb3RTY29wZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH1cbiAgaWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja3NfIH0gPSBzdGF0ZTtcbiAgICBpZiAoY2FsbGJhY2tzXykge1xuICAgICAgd2hpbGUgKGNhbGxiYWNrc18ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc18ucG9wKCk7XG4gICAgICAgIGNhbGxiYWNrKHJvb3RTY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlUGF0Y2hlc0FuZEZpbmFsaXplKHN0YXRlLCByb290U2NvcGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5jb3B5Xztcbn1cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVGaW5hbGl6ZWQoc3RhdGUpIHtcbiAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbn1cbnZhciBpc1NhbWVTY29wZSA9IChzdGF0ZSwgcm9vdFNjb3BlKSA9PiBzdGF0ZS5zY29wZV8gPT09IHJvb3RTY29wZTtcbnZhciBFTVBUWV9MT0NBVElPTlNfUkVTVUxUID0gW107XG5mdW5jdGlvbiB1cGRhdGVEcmFmdEluUGFyZW50KHBhcmVudCwgZHJhZnRWYWx1ZSwgZmluYWxpemVkVmFsdWUsIG9yaWdpbmFsS2V5KSB7XG4gIGNvbnN0IHBhcmVudENvcHkgPSBsYXRlc3QocGFyZW50KTtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlXztcbiAgaWYgKG9yaWdpbmFsS2V5ICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXQocGFyZW50Q29weSwgb3JpZ2luYWxLZXksIHBhcmVudFR5cGUpO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPT09IGRyYWZ0VmFsdWUpIHtcbiAgICAgIHNldChwYXJlbnRDb3B5LCBvcmlnaW5hbEtleSwgZmluYWxpemVkVmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhcmVudC5kcmFmdExvY2F0aW9uc18pIHtcbiAgICBjb25zdCBkcmFmdExvY2F0aW9ucyA9IHBhcmVudC5kcmFmdExvY2F0aW9uc18gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGVhY2gocGFyZW50Q29weSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChpc0RyYWZ0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gZHJhZnRMb2NhdGlvbnMuZ2V0KHZhbHVlKSB8fCBbXTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIGRyYWZ0TG9jYXRpb25zLnNldCh2YWx1ZSwga2V5cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbG9jYXRpb25zID0gcGFyZW50LmRyYWZ0TG9jYXRpb25zXy5nZXQoZHJhZnRWYWx1ZSkgPz8gRU1QVFlfTE9DQVRJT05TX1JFU1VMVDtcbiAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiBsb2NhdGlvbnMpIHtcbiAgICBzZXQocGFyZW50Q29weSwgbG9jYXRpb24sIGZpbmFsaXplZFZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJDaGlsZEZpbmFsaXphdGlvbkNhbGxiYWNrKHBhcmVudCwgY2hpbGQsIGtleSkge1xuICBwYXJlbnQuY2FsbGJhY2tzXy5wdXNoKGZ1bmN0aW9uIGNoaWxkQ2xlYW51cChyb290U2NvcGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGNoaWxkO1xuICAgIGlmICghc3RhdGUgfHwgIWlzU2FtZVNjb3BlKHN0YXRlLCByb290U2NvcGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3RTY29wZS5tYXBTZXRQbHVnaW5fPy5maXhTZXRDb250ZW50cyhzdGF0ZSk7XG4gICAgY29uc3QgZmluYWxpemVkVmFsdWUgPSBnZXRGaW5hbFZhbHVlKHN0YXRlKTtcbiAgICB1cGRhdGVEcmFmdEluUGFyZW50KHBhcmVudCwgc3RhdGUuZHJhZnRfID8/IHN0YXRlLCBmaW5hbGl6ZWRWYWx1ZSwga2V5KTtcbiAgICBnZW5lcmF0ZVBhdGNoZXNBbmRGaW5hbGl6ZShzdGF0ZSwgcm9vdFNjb3BlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNBbmRGaW5hbGl6ZShzdGF0ZSwgcm9vdFNjb3BlKSB7XG4gIGNvbnN0IHNob3VsZEZpbmFsaXplID0gc3RhdGUubW9kaWZpZWRfICYmICFzdGF0ZS5maW5hbGl6ZWRfICYmIChzdGF0ZS50eXBlXyA9PT0gMyAvKiBTZXQgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8gJiYgc3RhdGUuYWxsSW5kaWNlc1JlYXNzaWduZWRfIHx8IChzdGF0ZS5hc3NpZ25lZF8/LnNpemUgPz8gMCkgPiAwKTtcbiAgaWYgKHNob3VsZEZpbmFsaXplKSB7XG4gICAgY29uc3QgeyBwYXRjaFBsdWdpbl8gfSA9IHJvb3RTY29wZTtcbiAgICBpZiAocGF0Y2hQbHVnaW5fKSB7XG4gICAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGNoUGx1Z2luXy5nZXRQYXRoKHN0YXRlKTtcbiAgICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgICBwYXRjaFBsdWdpbl8uZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHJvb3RTY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtTdGF0ZUZpbmFsaXplZChzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNyb3NzUmVmZXJlbmNlKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCB7IHNjb3BlXyB9ID0gdGFyZ2V0O1xuICBpZiAoaXNEcmFmdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoaXNTYW1lU2NvcGUoc3RhdGUsIHNjb3BlXykpIHtcbiAgICAgIHN0YXRlLmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiBjcm9zc1JlZmVyZW5jZUNsZWFudXAoKSB7XG4gICAgICAgIHByZXBhcmVDb3B5KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGZpbmFsaXplZFZhbHVlID0gZ2V0RmluYWxWYWx1ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZURyYWZ0SW5QYXJlbnQodGFyZ2V0LCB2YWx1ZSwgZmluYWxpemVkVmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgdGFyZ2V0LmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiBuZXN0ZWREcmFmdENsZWFudXAoKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb3B5ID0gbGF0ZXN0KHRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0LnR5cGVfID09PSAzIC8qIFNldCAqLykge1xuICAgICAgICBpZiAodGFyZ2V0Q29weS5oYXModmFsdWUpKSB7XG4gICAgICAgICAgaGFuZGxlVmFsdWUodmFsdWUsIHNjb3BlXy5oYW5kbGVkU2V0Xywgc2NvcGVfKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdldCh0YXJnZXRDb3B5LCBrZXksIHRhcmdldC50eXBlXykgPT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHNjb3BlXy5kcmFmdHNfLmxlbmd0aCA+IDEgJiYgKHRhcmdldC5hc3NpZ25lZF8uZ2V0KGtleSkgPz8gZmFsc2UpID09PSB0cnVlICYmIHRhcmdldC5jb3B5Xykge1xuICAgICAgICAgICAgaGFuZGxlVmFsdWUoXG4gICAgICAgICAgICAgIGdldCh0YXJnZXQuY29weV8sIGtleSwgdGFyZ2V0LnR5cGVfKSxcbiAgICAgICAgICAgICAgc2NvcGVfLmhhbmRsZWRTZXRfLFxuICAgICAgICAgICAgICBzY29wZV9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVZhbHVlKHRhcmdldCwgaGFuZGxlZFNldCwgcm9vdFNjb3BlKSB7XG4gIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzRHJhZnQodGFyZ2V0KSB8fCBoYW5kbGVkU2V0Lmhhcyh0YXJnZXQpIHx8ICFpc0RyYWZ0YWJsZSh0YXJnZXQpIHx8IGlzRnJvemVuKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGhhbmRsZWRTZXQuYWRkKHRhcmdldCk7XG4gIGVhY2godGFyZ2V0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmIChpc0RyYWZ0KHZhbHVlKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gICAgICBpZiAoaXNTYW1lU2NvcGUoc3RhdGUsIHJvb3RTY29wZSkpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFZhbHVlID0gZ2V0RmluYWxWYWx1ZShzdGF0ZSk7XG4gICAgICAgIHNldCh0YXJnZXQsIGtleSwgdXBkYXRlZFZhbHVlLCB0YXJnZXQudHlwZV8pO1xuICAgICAgICBtYXJrU3RhdGVGaW5hbGl6ZWQoc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICBoYW5kbGVWYWx1ZSh2YWx1ZSwgaGFuZGxlZFNldCwgcm9vdFNjb3BlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBzcmMvY29yZS9wcm94eS50c1xuZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eShiYXNlLCBwYXJlbnQpIHtcbiAgY29uc3QgYmFzZUlzQXJyYXkgPSBpc0FycmF5KGJhc2UpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICB0eXBlXzogYmFzZUlzQXJyYXkgPyAxIC8qIEFycmF5ICovIDogMCAvKiBPYmplY3QgKi8sXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgLy8gYWN0dWFsbHkgaW5zdGFudGlhdGVkIGluIGBwcmVwYXJlQ29weSgpYFxuICAgIGFzc2lnbmVkXzogdm9pZCAwLFxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG4gICAgcGFyZW50XzogcGFyZW50LFxuICAgIC8vIFRoZSBiYXNlIHN0YXRlLlxuICAgIGJhc2VfOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0XzogbnVsbCxcbiAgICAvLyBzZXQgYmVsb3dcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuICAgIGNvcHlfOiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZV86IG51bGwsXG4gICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAvLyBgY2FsbGJhY2tzYCBhY3R1YWxseSBnZXRzIGFzc2lnbmVkIGluIGBjcmVhdGVQcm94eWBcbiAgICBjYWxsYmFja3NfOiB2b2lkIDBcbiAgfTtcbiAgbGV0IHRhcmdldCA9IHN0YXRlO1xuICBsZXQgdHJhcHMgPSBvYmplY3RUcmFwcztcbiAgaWYgKGJhc2VJc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cbiAgY29uc3QgeyByZXZva2UsIHByb3h5IH0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyk7XG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gW3Byb3h5LCBzdGF0ZV07XG59XG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSlcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgYXJyYXlQbHVnaW4gPSBzdGF0ZS5zY29wZV8uYXJyYXlNZXRob2RzUGx1Z2luXztcbiAgICBjb25zdCBpc0FycmF5V2l0aFN0cmluZ1Byb3AgPSBzdGF0ZS50eXBlXyA9PT0gMSAvKiBBcnJheSAqLyAmJiB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIjtcbiAgICBpZiAoaXNBcnJheVdpdGhTdHJpbmdQcm9wKSB7XG4gICAgICBpZiAoYXJyYXlQbHVnaW4/LmlzQXJyYXlPcGVyYXRpb25NZXRob2QocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UGx1Z2luLmNyZWF0ZU1ldGhvZEludGVyY2VwdG9yKHN0YXRlLCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBpZiAoIWhhcyhzb3VyY2UsIHByb3AsIHN0YXRlLnR5cGVfKSkge1xuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5V2l0aFN0cmluZ1Byb3AgJiYgc3RhdGUub3BlcmF0aW9uTWV0aG9kICYmIGFycmF5UGx1Z2luPy5pc011dGF0aW5nQXJyYXlNZXRob2QoXG4gICAgICBzdGF0ZS5vcGVyYXRpb25NZXRob2RcbiAgICApICYmIGlzQXJyYXlJbmRleChwcm9wKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBjb25zdCBjaGlsZEtleSA9IHN0YXRlLnR5cGVfID09PSAxIC8qIEFycmF5ICovID8gK3Byb3AgOiBwcm9wO1xuICAgICAgY29uc3QgY2hpbGREcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXywgdmFsdWUsIHN0YXRlLCBjaGlsZEtleSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV9bY2hpbGRLZXldID0gY2hpbGREcmFmdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBoYXMoc3RhdGUsIHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCBpbiBsYXRlc3Qoc3RhdGUpO1xuICB9LFxuICBvd25LZXlzKHN0YXRlKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKTtcbiAgfSxcbiAgc2V0KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuICAgIGlmIChkZXNjPy5zZXQpIHtcbiAgICAgIGRlc2Muc2V0LmNhbGwoc3RhdGUuZHJhZnRfLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQyID0gcGVlayhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnQyPy5bRFJBRlRfU1RBVEVdO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQocHJvcCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpcyh2YWx1ZSwgY3VycmVudDIpICYmICh2YWx1ZSAhPT0gdm9pZCAwIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCwgc3RhdGUudHlwZV8pKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAodmFsdWUgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfLnNldChwcm9wLCB0cnVlKTtcbiAgICBoYW5kbGVDcm9zc1JlZmVyZW5jZShzdGF0ZSwgcHJvcCwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCkge1xuICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KHByb3AsIGZhbHNlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShwcm9wKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfKSB7XG4gICAgICBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuICAgIGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICBbV1JJVEFCTEVdOiB0cnVlLFxuICAgICAgW0NPTkZJR1VSQUJMRV06IHN0YXRlLnR5cGVfICE9PSAxIC8qIEFycmF5ICovIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG4gICAgICBbRU5VTUVSQUJMRV06IGRlc2NbRU5VTUVSQUJMRV0sXG4gICAgICBbVkFMVUVdOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KCkge1xuICAgIGRpZSgxMSk7XG4gIH0sXG4gIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgZGllKDEyKTtcbiAgfVxufTtcbnZhciBhcnJheVRyYXBzID0ge307XG5mb3IgKGxldCBrZXkgaW4gb2JqZWN0VHJhcHMpIHtcbiAgbGV0IGZuID0gb2JqZWN0VHJhcHNba2V5XTtcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICBhcmdzWzBdID0gYXJnc1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24oc3RhdGUsIHByb3ApIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDEzKTtcbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHZvaWQgMCk7XG59O1xuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59O1xuZnVuY3Rpb24gcGVlayhkcmFmdCwgcHJvcCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgY29uc3Qgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gVkFMVUUgaW4gZGVzYyA/IGRlc2NbVkFMVUVdIDogKFxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHByb3RvID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KFxuICAgICAgc3RhdGUuYmFzZV8sXG4gICAgICBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5X1xuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvaW1tZXJDbGFzcy50c1xudmFyIEltbWVyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSBmYWxzZTtcbiAgICB0aGlzLnVzZVN0cmljdEl0ZXJhdGlvbl8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICAgICAqXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihiYXNlKSAmJiAhaXNGdW5jdGlvbihyZWNpcGUpKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UyID0gZGVmYXVsdEJhc2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UyLCAoZHJhZnQpID0+IHJlY2lwZS5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb24ocmVjaXBlKSlcbiAgICAgICAgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHZvaWQgMCAmJiAhaXNGdW5jdGlvbihwYXRjaExpc3RlbmVyKSlcbiAgICAgICAgZGllKDcpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoc2NvcGUsIGJhc2UsIHZvaWQgMCk7XG4gICAgICAgIGxldCBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNFcnJvcilcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCAhaXNPYmplY3Rpc2goYmFzZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORylcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGlzLmF1dG9GcmVlemVfKVxuICAgICAgICAgIGZyZWV6ZShyZXN1bHQsIHRydWUpO1xuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgICAgICBjb25zdCBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihQbHVnaW5QYXRjaGVzKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCB7XG4gICAgICAgICAgICBwYXRjaGVzXzogcCxcbiAgICAgICAgICAgIGludmVyc2VQYXRjaGVzXzogaXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcbiAgICB9O1xuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2UsIHJlY2lwZSkgPT4ge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oYmFzZSkpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgLi4uYXJncykgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdCkgPT4gYmFzZShkcmFmdCwgLi4uYXJncykpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgKHAsIGlwKSA9PiB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG4gICAgaWYgKGlzQm9vbGVhbihjb25maWc/LmF1dG9GcmVlemUpKVxuICAgICAgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgICBpZiAoaXNCb29sZWFuKGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkpKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWcudXNlU3RyaWN0U2hhbGxvd0NvcHkpO1xuICAgIGlmIChpc0Jvb2xlYW4oY29uZmlnPy51c2VTdHJpY3RJdGVyYXRpb24pKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RJdGVyYXRpb24oY29uZmlnLnVzZVN0cmljdEl0ZXJhdGlvbik7XG4gIH1cbiAgY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXG4gICAgICBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShzY29wZSwgYmFzZSwgdm9pZCAwKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pXG4gICAgICBkaWUoOSk7XG4gICAgY29uc3QgeyBzY29wZV86IHNjb3BlIH0gPSBzdGF0ZTtcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodm9pZCAwLCBzY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAgICovXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUGFzcyBmYWxzZSB0byB1c2UgZmFzdGVyIGl0ZXJhdGlvbiB0aGF0IHNraXBzIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICogYnV0IHN0aWxsIGhhbmRsZXMgc3ltYm9scyBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IGl0ZXJhdGlvbiBpcyBlbmFibGVkIChpbmNsdWRlcyBhbGwgb3duIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgc2V0VXNlU3RyaWN0SXRlcmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RJdGVyYXRpb25fID0gdmFsdWU7XG4gIH1cbiAgc2hvdWxkVXNlU3RyaWN0SXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVN0cmljdEl0ZXJhdGlvbl87XG4gIH1cbiAgYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG4gICAgY29uc3QgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihQbHVnaW5QYXRjaGVzKS5hcHBseVBhdGNoZXNfO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcbiAgICAgIGJhc2UsXG4gICAgICAoZHJhZnQpID0+IGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHJvb3RTY29wZSwgdmFsdWUsIHBhcmVudCwga2V5KSB7XG4gIGNvbnN0IFtkcmFmdCwgc3RhdGVdID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFBsdWdpbk1hcFNldCkucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KTtcbiAgY29uc3Qgc2NvcGUgPSBwYXJlbnQ/LnNjb3BlXyA/PyBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgc3RhdGUuY2FsbGJhY2tzXyA9IHBhcmVudD8uY2FsbGJhY2tzXyA/PyBbXTtcbiAgc3RhdGUua2V5XyA9IGtleTtcbiAgaWYgKHBhcmVudCAmJiBrZXkgIT09IHZvaWQgMCkge1xuICAgIHJlZ2lzdGVyQ2hpbGRGaW5hbGl6YXRpb25DYWxsYmFjayhwYXJlbnQsIHN0YXRlLCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNhbGxiYWNrc18ucHVzaChmdW5jdGlvbiByb290RHJhZnRDbGVhbnVwKHJvb3RTY29wZTIpIHtcbiAgICAgIHJvb3RTY29wZTIubWFwU2V0UGx1Z2luXz8uZml4U2V0Q29udGVudHMoc3RhdGUpO1xuICAgICAgY29uc3QgeyBwYXRjaFBsdWdpbl8gfSA9IHJvb3RTY29wZTI7XG4gICAgICBpZiAoc3RhdGUubW9kaWZpZWRfICYmIHBhdGNoUGx1Z2luXykge1xuICAgICAgICBwYXRjaFBsdWdpbl8uZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgW10sIHJvb3RTY29wZTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkcmFmdDtcbn1cblxuLy8gc3JjL2NvcmUvY3VycmVudC50c1xuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxuICAgIGRpZSgxMCwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkgfHwgaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGxldCBjb3B5O1xuICBsZXQgc3RyaWN0ID0gdHJ1ZTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pXG4gICAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5Xyk7XG4gICAgc3RyaWN0ID0gc3RhdGUuc2NvcGVfLmltbWVyXy5zaG91bGRVc2VTdHJpY3RJdGVyYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHRydWUpO1xuICB9XG4gIGVhY2goXG4gICAgY29weSxcbiAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG4gICAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XG4gICAgfSxcbiAgICBzdHJpY3RcbiAgKTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBzcmMvcGx1Z2lucy9wYXRjaGVzLnRzXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICBjb25zdCBlcnJvck9mZnNldCA9IDE2O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG4gICAgICBmdW5jdGlvbihvcCkge1xuICAgICAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGg7XG4gICAgICB9LFxuICAgICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhdGgoc3RhdGUsIHBhdGggPSBbXSkge1xuICAgIGlmIChzdGF0ZS5rZXlfICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHBhcmVudENvcHkgPSBzdGF0ZS5wYXJlbnRfLmNvcHlfID8/IHN0YXRlLnBhcmVudF8uYmFzZV87XG4gICAgICBjb25zdCBwcm94eURyYWZ0ID0gZ2V0UHJveHlEcmFmdChnZXQocGFyZW50Q29weSwgc3RhdGUua2V5XykpO1xuICAgICAgY29uc3QgdmFsdWVBdEtleSA9IGdldChwYXJlbnRDb3B5LCBzdGF0ZS5rZXlfKTtcbiAgICAgIGlmICh2YWx1ZUF0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVBdEtleSAhPT0gc3RhdGUuZHJhZnRfICYmIHZhbHVlQXRLZXkgIT09IHN0YXRlLmJhc2VfICYmIHZhbHVlQXRLZXkgIT09IHN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHByb3h5RHJhZnQgIT0gbnVsbCAmJiBwcm94eURyYWZ0LmJhc2VfICE9PSBzdGF0ZS5iYXNlXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU2V0MiA9IHN0YXRlLnBhcmVudF8udHlwZV8gPT09IDMgLyogU2V0ICovO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGlmIChpc1NldDIpIHtcbiAgICAgICAgY29uc3Qgc2V0UGFyZW50ID0gc3RhdGUucGFyZW50XztcbiAgICAgICAga2V5ID0gQXJyYXkuZnJvbShzZXRQYXJlbnQuZHJhZnRzXy5rZXlzKCkpLmluZGV4T2Yoc3RhdGUua2V5Xyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBzdGF0ZS5rZXlfO1xuICAgICAgfVxuICAgICAgaWYgKCEoaXNTZXQyICYmIHBhcmVudENvcHkuc2l6ZSA+IGtleSB8fCBoYXMocGFyZW50Q29weSwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIHJldHVybiBnZXRQYXRoKHN0YXRlLnBhcmVudF8sIHBhdGgpO1xuICAgIH1cbiAgICBwYXRoLnJldmVyc2UoKTtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZVBhdGgoc3RhdGUuY29weV8sIHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgbGV0IGN1cnJlbnQyID0gYmFzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwYXRoW2ldO1xuICAgICAgY3VycmVudDIgPSBnZXQoY3VycmVudDIsIGtleSk7XG4gICAgICBpZiAoIWlzT2JqZWN0aXNoKGN1cnJlbnQyKSB8fCBjdXJyZW50MiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIHBhdGggYXQgJyR7cGF0aC5qb2luKFwiL1wiKX0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50MjtcbiAgfVxuICBjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIGNvbnN0IEFERCA9IFwiYWRkXCI7XG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBzY29wZSkge1xuICAgIGlmIChzdGF0ZS5zY29wZV8ucHJvY2Vzc2VkRm9yUGF0Y2hlc18uaGFzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5zY29wZV8ucHJvY2Vzc2VkRm9yUGF0Y2hlc18uYWRkKHN0YXRlKTtcbiAgICBjb25zdCB7IHBhdGNoZXNfLCBpbnZlcnNlUGF0Y2hlc18gfSA9IHNjb3BlO1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XG4gICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXNfLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzX1xuICAgICAgICApO1xuICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlc18sXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNfXG4gICAgICAgICk7XG4gICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXNfLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzX1xuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGFzc2lnbmVkXyB9ID0gc3RhdGU7XG4gICAgbGV0IGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW2Jhc2VfLCBjb3B5X10gPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIFtwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdO1xuICAgIH1cbiAgICBjb25zdCBhbGxSZWFzc2lnbmVkID0gc3RhdGUuYWxsSW5kaWNlc1JlYXNzaWduZWRfID09PSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvcGllZEl0ZW0gPSBjb3B5X1tpXTtcbiAgICAgIGNvbnN0IGJhc2VJdGVtID0gYmFzZV9baV07XG4gICAgICBjb25zdCBpc0Fzc2lnbmVkID0gYWxsUmVhc3NpZ25lZCB8fCBhc3NpZ25lZF8/LmdldChpLnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKGlzQXNzaWduZWQgJiYgY29waWVkSXRlbSAhPT0gYmFzZUl0ZW0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGNvcGllZEl0ZW0/LltEUkFGVF9TVEFURV07XG4gICAgICAgIGlmIChjaGlsZFN0YXRlICYmIGNoaWxkU3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcGllZEl0ZW0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlSXRlbSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGNvcHlfLmxlbmd0aCAtIDE7IGJhc2VfLmxlbmd0aCA8PSBpOyAtLWkpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBjb25zdCB7IGJhc2VfLCBjb3B5XywgdHlwZV8gfSA9IHN0YXRlO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSwgdHlwZV8pO1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSwgdHlwZV8pO1xuICAgICAgY29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKFxuICAgICAgICBvcCA9PT0gUkVNT1ZFID8geyBvcCwgcGF0aCB9IDogeyBvcCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKHZhbHVlKSB9XG4gICAgICApO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcbiAgICAgICAgb3AgPT09IEFERCA/IHsgb3A6IFJFTU9WRSwgcGF0aCB9IDogb3AgPT09IFJFTU9WRSA/IHsgb3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfSA6IHsgb3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgc2NvcGUpIHtcbiAgICBjb25zdCB7IHBhdGNoZXNfLCBpbnZlcnNlUGF0Y2hlc18gfSA9IHNjb3BlO1xuICAgIHBhdGNoZXNfLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHZvaWQgMCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXNfLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBiYXNlVmFsdWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRoLCBvcCB9ID0gcGF0Y2g7XG4gICAgICBsZXQgYmFzZSA9IGRyYWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIGxldCBwID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMCAvKiBPYmplY3QgKi8gfHwgcGFyZW50VHlwZSA9PT0gMSAvKiBBcnJheSAqLykgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gQ09OU1RSVUNUT1IpKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihiYXNlKSAmJiBwID09PSBQUk9UT1RZUEUpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICghaXNPYmplY3Rpc2goYmFzZSkpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMiwgcGF0aC5qb2luKFwiL1wiKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpO1xuICAgICAgY29uc3Qga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxuICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAoaXNBcnJheShvYmopKVxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpXG4gICAgICByZXR1cm4gbmV3IE1hcChcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuICAgICAgKTtcbiAgICBpZiAoaXNTZXQob2JqKSlcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSlcbiAgICAgIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvYmopIHtcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XG4gICAgICByZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxuICBsb2FkUGx1Z2luKFBsdWdpblBhdGNoZXMsIHtcbiAgICBhcHBseVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfLFxuICAgIGdldFBhdGhcbiAgfSk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL21hcHNldC50c1xuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICBjbGFzcyBEcmFmdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDIgLyogTWFwICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYXNzaWduZWRfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBjYWxsYmFja3NfOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgICBoYW5kbGVDcm9zc1JlZmVyZW5jZShzdGF0ZSwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmJhc2VfLmhhcyhrZXkpKSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZWFjaChzdGF0ZS5iYXNlXywgKGtleSkgPT4ge1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWUsIGtleSwgX21hcCkgPT4ge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KGtleSksIGtleSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gc3RhdGUuYmFzZV8uZ2V0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8sIHZhbHVlLCBzdGF0ZSwga2V5KTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIGRyYWZ0KTtcbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMuZW50cmllcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eU1hcF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xuICAgIHJldHVybiBbbWFwLCBtYXBbRFJBRlRfU1RBVEVdXTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEcmFmdFNldCBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDMgLyogU2V0ICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIGFzc2lnbmVkXzogdm9pZCAwLFxuICAgICAgICBjYWxsYmFja3NfOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICAgIGhhbmRsZUNyb3NzUmVmZXJlbmNlKHN0YXRlLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpID8gc3RhdGUuY29weV8uZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkgOiAoXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZhbHNlXG4gICAgICApKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZW50cmllcygpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIGNvbnN0IHNldDIgPSBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xuICAgIHJldHVybiBbc2V0Miwgc2V0MltEUkFGVF9TVEFURV1dO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuY29weV8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLCB2YWx1ZSwgc3RhdGUsIHZhbHVlKTtcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZChkcmFmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXylcbiAgICAgIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cbiAgZnVuY3Rpb24gZml4U2V0Q29udGVudHModGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC50eXBlXyA9PT0gMyAvKiBTZXQgKi8gJiYgdGFyZ2V0LmNvcHlfKSB7XG4gICAgICBjb25zdCBjb3B5ID0gbmV3IFNldCh0YXJnZXQuY29weV8pO1xuICAgICAgdGFyZ2V0LmNvcHlfLmNsZWFyKCk7XG4gICAgICBjb3B5LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHRhcmdldC5jb3B5Xy5hZGQoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBsb2FkUGx1Z2luKFBsdWdpbk1hcFNldCwgeyBwcm94eU1hcF8sIHByb3h5U2V0XywgZml4U2V0Q29udGVudHMgfSk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL2FycmF5TWV0aG9kcy50c1xuZnVuY3Rpb24gZW5hYmxlQXJyYXlNZXRob2RzKCkge1xuICBjb25zdCBTSElGVElOR19NRVRIT0RTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wic2hpZnRcIiwgXCJ1bnNoaWZ0XCJdKTtcbiAgY29uc3QgUVVFVUVfTUVUSE9EUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInB1c2hcIiwgXCJwb3BcIl0pO1xuICBjb25zdCBSRVNVTFRfUkVUVVJOSU5HX01FVEhPRFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgLi4uUVVFVUVfTUVUSE9EUyxcbiAgICAuLi5TSElGVElOR19NRVRIT0RTXG4gIF0pO1xuICBjb25zdCBSRU9SREVSSU5HX01FVEhPRFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJyZXZlcnNlXCIsIFwic29ydFwiXSk7XG4gIGNvbnN0IE1VVEFUSU5HX01FVEhPRFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgLi4uUkVTVUxUX1JFVFVSTklOR19NRVRIT0RTLFxuICAgIC4uLlJFT1JERVJJTkdfTUVUSE9EUyxcbiAgICBcInNwbGljZVwiXG4gIF0pO1xuICBjb25zdCBGSU5EX01FVEhPRFMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJmaW5kXCIsIFwiZmluZExhc3RcIl0pO1xuICBjb25zdCBOT05fTVVUQVRJTkdfTUVUSE9EUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICBcImZpbHRlclwiLFxuICAgIFwic2xpY2VcIixcbiAgICBcImNvbmNhdFwiLFxuICAgIFwiZmxhdFwiLFxuICAgIC4uLkZJTkRfTUVUSE9EUyxcbiAgICBcImZpbmRJbmRleFwiLFxuICAgIFwiZmluZExhc3RJbmRleFwiLFxuICAgIFwic29tZVwiLFxuICAgIFwiZXZlcnlcIixcbiAgICBcImluZGV4T2ZcIixcbiAgICBcImxhc3RJbmRleE9mXCIsXG4gICAgXCJpbmNsdWRlc1wiLFxuICAgIFwiam9pblwiLFxuICAgIFwidG9TdHJpbmdcIixcbiAgICBcInRvTG9jYWxlU3RyaW5nXCJcbiAgXSk7XG4gIGZ1bmN0aW9uIGlzTXV0YXRpbmdBcnJheU1ldGhvZChtZXRob2QpIHtcbiAgICByZXR1cm4gTVVUQVRJTkdfTUVUSE9EUy5oYXMobWV0aG9kKTtcbiAgfVxuICBmdW5jdGlvbiBpc05vbk11dGF0aW5nQXJyYXlNZXRob2QobWV0aG9kKSB7XG4gICAgcmV0dXJuIE5PTl9NVVRBVElOR19NRVRIT0RTLmhhcyhtZXRob2QpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQXJyYXlPcGVyYXRpb25NZXRob2QobWV0aG9kKSB7XG4gICAgcmV0dXJuIGlzTXV0YXRpbmdBcnJheU1ldGhvZChtZXRob2QpIHx8IGlzTm9uTXV0YXRpbmdBcnJheU1ldGhvZChtZXRob2QpO1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyT3BlcmF0aW9uKHN0YXRlLCBtZXRob2QpIHtcbiAgICBzdGF0ZS5vcGVyYXRpb25NZXRob2QgPSBtZXRob2Q7XG4gIH1cbiAgZnVuY3Rpb24gZXhpdE9wZXJhdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLm9wZXJhdGlvbk1ldGhvZCA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBleGVjdXRlQXJyYXlNZXRob2Qoc3RhdGUsIG9wZXJhdGlvbiwgbWFya0xlbmd0aCA9IHRydWUpIHtcbiAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gb3BlcmF0aW9uKCk7XG4gICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIGlmIChtYXJrTGVuZ3RoKVxuICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChcImxlbmd0aFwiLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtBbGxJbmRpY2VzUmVhc3NpZ25lZChzdGF0ZSkge1xuICAgIHN0YXRlLmFsbEluZGljZXNSZWFzc2lnbmVkXyA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2xpY2VJbmRleChpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKGluZGV4LCBsZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNpbXBsZU9wZXJhdGlvbihzdGF0ZSwgbWV0aG9kLCBhcmdzKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVBcnJheU1ldGhvZChzdGF0ZSwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc3RhdGUuY29weV9bbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgIGlmIChTSElGVElOR19NRVRIT0RTLmhhcyhtZXRob2QpKSB7XG4gICAgICAgIG1hcmtBbGxJbmRpY2VzUmVhc3NpZ25lZChzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUkVTVUxUX1JFVFVSTklOR19NRVRIT0RTLmhhcyhtZXRob2QpID8gcmVzdWx0IDogc3RhdGUuZHJhZnRfO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVJlb3JkZXJpbmdPcGVyYXRpb24oc3RhdGUsIG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBleGVjdXRlQXJyYXlNZXRob2QoXG4gICAgICBzdGF0ZSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgO1xuICAgICAgICBzdGF0ZS5jb3B5X1ttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICBtYXJrQWxsSW5kaWNlc1JlYXNzaWduZWQoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGUuZHJhZnRfO1xuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZXRob2RJbnRlcmNlcHRvcihzdGF0ZSwgb3JpZ2luYWxNZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW50ZXJjZXB0ZWRNZXRob2QoLi4uYXJncykge1xuICAgICAgY29uc3QgbWV0aG9kID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICBlbnRlck9wZXJhdGlvbihzdGF0ZSwgbWV0aG9kKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc011dGF0aW5nQXJyYXlNZXRob2QobWV0aG9kKSkge1xuICAgICAgICAgIGlmIChSRVNVTFRfUkVUVVJOSU5HX01FVEhPRFMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTaW1wbGVPcGVyYXRpb24oc3RhdGUsIG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChSRU9SREVSSU5HX01FVEhPRFMuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZW9yZGVyaW5nT3BlcmF0aW9uKHN0YXRlLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInNwbGljZVwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBleGVjdXRlQXJyYXlNZXRob2QoXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAoKSA9PiBzdGF0ZS5jb3B5Xy5zcGxpY2UoLi4uYXJncylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYXJrQWxsSW5kaWNlc1JlYXNzaWduZWQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZU5vbk11dGF0aW5nT3BlcmF0aW9uKHN0YXRlLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBleGl0T3BlcmF0aW9uKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5vbk11dGF0aW5nT3BlcmF0aW9uKHN0YXRlLCBtZXRob2QsIGFyZ3MpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGlmIChtZXRob2QgPT09IFwiZmlsdGVyXCIpIHtcbiAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGFyZ3NbMF07XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoc291cmNlW2ldLCBpLCBzb3VyY2UpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGUuZHJhZnRfW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKEZJTkRfTUVUSE9EUy5oYXMobWV0aG9kKSkge1xuICAgICAgY29uc3QgcHJlZGljYXRlID0gYXJnc1swXTtcbiAgICAgIGNvbnN0IGlzRm9yd2FyZCA9IG1ldGhvZCA9PT0gXCJmaW5kXCI7XG4gICAgICBjb25zdCBzdGVwID0gaXNGb3J3YXJkID8gMSA6IC0xO1xuICAgICAgY29uc3Qgc3RhcnQgPSBpc0ZvcndhcmQgPyAwIDogc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgc291cmNlLmxlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoc291cmNlW2ldLCBpLCBzb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmRyYWZ0X1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJzbGljZVwiKSB7XG4gICAgICBjb25zdCByYXdTdGFydCA9IGFyZ3NbMF0gPz8gMDtcbiAgICAgIGNvbnN0IHJhd0VuZCA9IGFyZ3NbMV0gPz8gc291cmNlLmxlbmd0aDtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm9ybWFsaXplU2xpY2VJbmRleChyYXdTdGFydCwgc291cmNlLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmQgPSBub3JtYWxpemVTbGljZUluZGV4KHJhd0VuZCwgc291cmNlLmxlbmd0aCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlLmRyYWZ0X1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlW21ldGhvZF0oLi4uYXJncyk7XG4gIH1cbiAgbG9hZFBsdWdpbihQbHVnaW5BcnJheU1ldGhvZHMsIHtcbiAgICBjcmVhdGVNZXRob2RJbnRlcmNlcHRvcixcbiAgICBpc0FycmF5T3BlcmF0aW9uTWV0aG9kLFxuICAgIGlzTXV0YXRpbmdBcnJheU1ldGhvZFxuICB9KTtcbn1cblxuLy8gc3JjL2ltbWVyLnRzXG52YXIgaW1tZXIgPSBuZXcgSW1tZXIyKCk7XG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID0gLyogQF9fUFVSRV9fICovIGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBzZXRBdXRvRnJlZXplID0gLyogQF9fUFVSRV9fICovIGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG52YXIgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkgPSAvKiBAX19QVVJFX18gKi8gaW1tZXIuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChcbiAgaW1tZXJcbik7XG52YXIgc2V0VXNlU3RyaWN0SXRlcmF0aW9uID0gLyogQF9fUFVSRV9fICovIGltbWVyLnNldFVzZVN0cmljdEl0ZXJhdGlvbi5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBhcHBseVBhdGNoZXMgPSAvKiBAX19QVVJFX18gKi8gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xudmFyIGNyZWF0ZURyYWZ0ID0gLyogQF9fUFVSRV9fICovIGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xudmFyIGZpbmlzaERyYWZ0ID0gLyogQF9fUFVSRV9fICovIGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xudmFyIGNhc3REcmFmdCA9ICh2YWx1ZSkgPT4gdmFsdWU7XG52YXIgY2FzdEltbXV0YWJsZSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5leHBvcnQge1xuICBJbW1lcjIgYXMgSW1tZXIsXG4gIGFwcGx5UGF0Y2hlcyxcbiAgY2FzdERyYWZ0LFxuICBjYXN0SW1tdXRhYmxlLFxuICBjcmVhdGVEcmFmdCxcbiAgY3VycmVudCxcbiAgZW5hYmxlQXJyYXlNZXRob2RzLFxuICBlbmFibGVNYXBTZXQsXG4gIGVuYWJsZVBhdGNoZXMsXG4gIGZpbmlzaERyYWZ0LFxuICBmcmVlemUsXG4gIERSQUZUQUJMRSBhcyBpbW1lcmFibGUsXG4gIGlzRHJhZnQsXG4gIGlzRHJhZnRhYmxlLFxuICBOT1RISU5HIGFzIG5vdGhpbmcsXG4gIG9yaWdpbmFsLFxuICBwcm9kdWNlLFxuICBwcm9kdWNlV2l0aFBhdGNoZXMsXG4gIHNldEF1dG9GcmVlemUsXG4gIHNldFVzZVN0cmljdEl0ZXJhdGlvbixcbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5tanMubWFwIl0sIm5hbWVzIjpbIk5PVEhJTkciLCJTeW1ib2wiLCJmb3IiLCJEUkFGVEFCTEUiLCJEUkFGVF9TVEFURSIsImVycm9ycyIsInByb2Nlc3MiLCJwbHVnaW4iLCJ0aGluZyIsImRhdGEiLCJkaWUiLCJlcnJvciIsImFyZ3MiLCJlIiwibXNnIiwiaXNGdW5jdGlvbiIsImFwcGx5IiwiRXJyb3IiLCJPIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJDT05TVFJVQ1RPUiIsIlBST1RPVFlQRSIsIkNPTkZJR1VSQUJMRSIsIkVOVU1FUkFCTEUiLCJXUklUQUJMRSIsIlZBTFVFIiwiaXNEcmFmdCIsInZhbHVlIiwiaXNEcmFmdGFibGUiLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsImlzTWFwIiwiaXNTZXQiLCJvYmplY3RDdG9yU3RyaW5nIiwidG9TdHJpbmciLCJjYWNoZWRDdG9yU3RyaW5ncyIsIldlYWtNYXAiLCJpc09iamVjdGlzaCIsInByb3RvIiwiQ3RvciIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImN0b3JTdHJpbmciLCJnZXQiLCJGdW5jdGlvbiIsInNldCIsIm9yaWdpbmFsIiwiYmFzZV8iLCJlYWNoIiwib2JqIiwiaXRlciIsInN0cmljdCIsImdldEFyY2h0eXBlIiwia2V5cyIsIlJlZmxlY3QiLCJvd25LZXlzIiwiZm9yRWFjaCIsImtleSIsImVudHJ5IiwiaW5kZXgiLCJzdGF0ZSIsInR5cGVfIiwiaGFzIiwicHJvcCIsInR5cGUiLCJwcm9wT3JPbGRWYWx1ZSIsImFkZCIsImlzIiwieCIsInkiLCJBcnJheSIsInRhcmdldCIsIk1hcCIsIlNldCIsImlzQm9vbGVhbiIsImlzQXJyYXlJbmRleCIsIm4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJTdHJpbmciLCJnZXRQcm94eURyYWZ0IiwibGF0ZXN0IiwiY29weV8iLCJnZXRWYWx1ZSIsInByb3h5RHJhZnQiLCJnZXRGaW5hbFZhbHVlIiwibW9kaWZpZWRfIiwic2hhbGxvd0NvcHkiLCJiYXNlIiwic2xpY2UiLCJpc1BsYWluIiwiZGVzY3JpcHRvcnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiaSIsImxlbmd0aCIsImRlc2MiLCJjcmVhdGUiLCJhc3NpZ24iLCJmcmVlemUiLCJkZWVwIiwiaXNGcm96ZW4iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZG9udE11dGF0ZU1ldGhvZE92ZXJyaWRlIiwiY2xlYXIiLCJkZWxldGUiLCJfa2V5IiwiZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIiwiUGx1Z2luTWFwU2V0IiwiUGx1Z2luUGF0Y2hlcyIsIlBsdWdpbkFycmF5TWV0aG9kcyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJpc1BsdWdpbkxvYWRlZCIsImxvYWRQbHVnaW4iLCJpbXBsZW1lbnRhdGlvbiIsImN1cnJlbnRTY29wZSIsImdldEN1cnJlbnRTY29wZSIsImNyZWF0ZVNjb3BlIiwicGFyZW50XyIsImltbWVyXyIsImRyYWZ0c18iLCJjYW5BdXRvRnJlZXplXyIsInVuZmluYWxpemVkRHJhZnRzXyIsImhhbmRsZWRTZXRfIiwicHJvY2Vzc2VkRm9yUGF0Y2hlc18iLCJtYXBTZXRQbHVnaW5fIiwiYXJyYXlNZXRob2RzUGx1Z2luXyIsInVzZVBhdGNoZXNJblNjb3BlIiwic2NvcGUiLCJwYXRjaExpc3RlbmVyIiwicGF0Y2hQbHVnaW5fIiwicGF0Y2hlc18iLCJpbnZlcnNlUGF0Y2hlc18iLCJwYXRjaExpc3RlbmVyXyIsInJldm9rZVNjb3BlIiwibGVhdmVTY29wZSIsInJldm9rZURyYWZ0IiwiZW50ZXJTY29wZSIsImltbWVyMiIsImRyYWZ0IiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsInJlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJmaW5hbGl6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsIm1heWJlRnJlZXplIiwicm9vdFNjb3BlIiwiZmluYWxWYWx1ZSIsImhhbmRsZVZhbHVlIiwiaXNTYW1lU2NvcGUiLCJmaW5hbGl6ZWRfIiwiY2FsbGJhY2tzXyIsImNhbGxiYWNrIiwicG9wIiwiZ2VuZXJhdGVQYXRjaGVzQW5kRmluYWxpemUiLCJhdXRvRnJlZXplXyIsIm1hcmtTdGF0ZUZpbmFsaXplZCIsInNjb3BlXyIsIkVNUFRZX0xPQ0FUSU9OU19SRVNVTFQiLCJ1cGRhdGVEcmFmdEluUGFyZW50IiwicGFyZW50IiwiZHJhZnRWYWx1ZSIsImZpbmFsaXplZFZhbHVlIiwib3JpZ2luYWxLZXkiLCJwYXJlbnRDb3B5IiwicGFyZW50VHlwZSIsImN1cnJlbnRWYWx1ZSIsImRyYWZ0TG9jYXRpb25zXyIsImRyYWZ0TG9jYXRpb25zIiwicHVzaCIsImxvY2F0aW9ucyIsImxvY2F0aW9uIiwicmVnaXN0ZXJDaGlsZEZpbmFsaXphdGlvbkNhbGxiYWNrIiwiY2hpbGQiLCJjaGlsZENsZWFudXAiLCJmaXhTZXRDb250ZW50cyIsImRyYWZ0XyIsInNob3VsZEZpbmFsaXplIiwiYWxsSW5kaWNlc1JlYXNzaWduZWRfIiwiYXNzaWduZWRfIiwic2l6ZSIsImJhc2VQYXRoIiwiZ2V0UGF0aCIsImdlbmVyYXRlUGF0Y2hlc18iLCJoYW5kbGVDcm9zc1JlZmVyZW5jZSIsImNyb3NzUmVmZXJlbmNlQ2xlYW51cCIsInByZXBhcmVDb3B5IiwibmVzdGVkRHJhZnRDbGVhbnVwIiwidGFyZ2V0Q29weSIsImhhbmRsZWRTZXQiLCJ1cGRhdGVkVmFsdWUiLCJjcmVhdGVQcm94eVByb3h5IiwiYmFzZUlzQXJyYXkiLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsInJldm9rZSIsInByb3h5IiwiUHJveHkiLCJyZXZvY2FibGUiLCJhcnJheVBsdWdpbiIsImlzQXJyYXlXaXRoU3RyaW5nUHJvcCIsImlzQXJyYXlPcGVyYXRpb25NZXRob2QiLCJjcmVhdGVNZXRob2RJbnRlcmNlcHRvciIsInNvdXJjZSIsInJlYWRQcm9wRnJvbVByb3RvIiwib3BlcmF0aW9uTWV0aG9kIiwiaXNNdXRhdGluZ0FycmF5TWV0aG9kIiwicGVlayIsImNoaWxkS2V5IiwiY2hpbGREcmFmdCIsImNyZWF0ZVByb3h5IiwiZ2V0RGVzY3JpcHRvckZyb21Qcm90byIsImN1cnJlbnQyIiwiY3VycmVudFN0YXRlIiwibWFya0NoYW5nZWQiLCJpc05hTiIsImRlbGV0ZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwib3duZXIiLCJkZWZpbmVQcm9wZXJ0eSIsInNldFByb3RvdHlwZU9mIiwiZm4iLCJhcmd1bWVudHMiLCJwYXJzZUludCIsInVzZVN0cmljdFNoYWxsb3dDb3B5XyIsIkltbWVyMiIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwidXNlU3RyaWN0SXRlcmF0aW9uXyIsInByb2R1Y2UiLCJyZWNpcGUiLCJkZWZhdWx0QmFzZSIsInNlbGYiLCJjdXJyaWVkUHJvZHVjZSIsImJhc2UyIiwiaGFzRXJyb3IiLCJwIiwiaXAiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJwYXRjaGVzIiwiaW52ZXJzZVBhdGNoZXMiLCJhdXRvRnJlZXplIiwic2V0QXV0b0ZyZWV6ZSIsInVzZVN0cmljdFNoYWxsb3dDb3B5Iiwic2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkiLCJ1c2VTdHJpY3RJdGVyYXRpb24iLCJzZXRVc2VTdHJpY3RJdGVyYXRpb24iLCJjcmVhdGVEcmFmdCIsImN1cnJlbnQiLCJmaW5pc2hEcmFmdCIsInNob3VsZFVzZVN0cmljdEl0ZXJhdGlvbiIsImFwcGx5UGF0Y2hlcyIsInBhdGNoIiwicGF0aCIsIm9wIiwiYXBwbHlQYXRjaGVzSW1wbCIsImFwcGx5UGF0Y2hlc18iLCJwcm94eU1hcF8iLCJwcm94eVNldF8iLCJrZXlfIiwicm9vdERyYWZ0Q2xlYW51cCIsInJvb3RTY29wZTIiLCJjdXJyZW50SW1wbCIsImNvcHkiLCJjaGlsZFZhbHVlIiwiZW5hYmxlUGF0Y2hlcyIsImVycm9yT2Zmc2V0IiwidmFsdWVBdEtleSIsImlzU2V0MiIsInNldFBhcmVudCIsImZyb20iLCJpbmRleE9mIiwicmV2ZXJzZSIsInJlc29sdmVQYXRoIiwiam9pbiIsIlJFUExBQ0UiLCJBREQiLCJSRU1PVkUiLCJnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQiLCJnZW5lcmF0ZUFycmF5UGF0Y2hlcyIsImdlbmVyYXRlU2V0UGF0Y2hlcyIsImFsbFJlYXNzaWduZWQiLCJjb3BpZWRJdGVtIiwiYmFzZUl0ZW0iLCJpc0Fzc2lnbmVkIiwiY2hpbGRTdGF0ZSIsImNvbmNhdCIsImNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkIiwiYXNzaWduZWRWYWx1ZSIsIm9yaWdWYWx1ZSIsInVuc2hpZnQiLCJiYXNlVmFsdWUiLCJyZXBsYWNlbWVudCIsImRlZXBDbG9uZVBhdGNoVmFsdWUiLCJzcGxpY2UiLCJtYXAiLCJlbnRyaWVzIiwiayIsInYiLCJjbG9uZWQiLCJlbmFibGVNYXBTZXQiLCJEcmFmdE1hcCIsImFzc2VydFVucmV2b2tlZCIsInByZXBhcmVNYXBDb3B5IiwiY2IiLCJ0aGlzQXJnIiwiX3ZhbHVlIiwiX21hcCIsInZhbHVlcyIsIml0ZXJhdG9yIiwibmV4dCIsInIiLCJkb25lIiwiRHJhZnRTZXQiLCJwcmVwYXJlU2V0Q29weSIsInNldDIiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5hYmxlQXJyYXlNZXRob2RzIiwiU0hJRlRJTkdfTUVUSE9EUyIsIlFVRVVFX01FVEhPRFMiLCJSRVNVTFRfUkVUVVJOSU5HX01FVEhPRFMiLCJSRU9SREVSSU5HX01FVEhPRFMiLCJNVVRBVElOR19NRVRIT0RTIiwiRklORF9NRVRIT0RTIiwiTk9OX01VVEFUSU5HX01FVEhPRFMiLCJtZXRob2QiLCJpc05vbk11dGF0aW5nQXJyYXlNZXRob2QiLCJlbnRlck9wZXJhdGlvbiIsImV4aXRPcGVyYXRpb24iLCJleGVjdXRlQXJyYXlNZXRob2QiLCJvcGVyYXRpb24iLCJtYXJrTGVuZ3RoIiwibWFya0FsbEluZGljZXNSZWFzc2lnbmVkIiwibm9ybWFsaXplU2xpY2VJbmRleCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJoYW5kbGVTaW1wbGVPcGVyYXRpb24iLCJoYW5kbGVSZW9yZGVyaW5nT3BlcmF0aW9uIiwib3JpZ2luYWxNZXRob2QiLCJpbnRlcmNlcHRlZE1ldGhvZCIsInJlcyIsImhhbmRsZU5vbk11dGF0aW5nT3BlcmF0aW9uIiwicHJlZGljYXRlIiwiaXNGb3J3YXJkIiwic3RlcCIsInN0YXJ0IiwicmF3U3RhcnQiLCJyYXdFbmQiLCJlbmQiLCJpbW1lciIsImJpbmQiLCJjYXN0RHJhZnQiLCJjYXN0SW1tdXRhYmxlIiwiSW1tZXIiLCJpbW1lcmFibGUiLCJub3RoaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/immer@11.1.3/node_modules/immer/dist/immer.mjs\n");

/***/ })

};
;